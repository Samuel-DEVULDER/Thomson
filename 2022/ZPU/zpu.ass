(main)zpu
   ORG   $6300

safe SET 0

   SETDP */256

* loads a continuated immediate value
* B=xxxxxxx0 (value*2)
opIM_nxt
   LSR   ,U          ; rotate TOS 7 bits left and add B/2 at the bottom
   LDA   1,U
   RORA
   STA   ,U          ; byte 0 is byte 1 rotated right once
   LDA   2,U
   RORA
   STA   1,U         ; byte 1 is byte 2 rotated right once
   LDA   3,U
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   STD   2,U         ; write lower word
   LDB   ,y+         ; is next opcode an opIm?
   BMI   chkPC       ; yes => just increment PC
   LDA   #$81        ; no => disable hook ($81=CMPA)
   STA   <opIM       ; (write CMPA as the first instructon of opIM)
   BRA   chkPC       ; next instruction (B already fetched)


* loads a 7 bit immediate value
* B=xxxxxxx0 (value*2)
opIM
   BRN   opIM_nxt    ; hook to go to continued version (dynamic code)
   ASRB              ; left align signed value
   SEX               ; extends sign to A ($00 or $FF)
   PSHU  D           ; push lower word
   STA   ,-U         ; push high byte (sign)
   STA   ,-U         ; push high byte (sign)
   LDB   ,Y+         ; is next opcode an immediate value?
   BPL   chkPC       ; no => no change in hook. just update the PC reg.
   LDA   #$20        ; yes => mak hook go to opIM_nxt ($20=BRA)
   STA   <opIM       ; (write a BRA as the first instructio, of opIM)
   BRA   chkPC       ; next instruction (B already fetched)

* safe version of getAddr for long values
getAddrL
   IF safe
   LDB   #%11111100
   ANDB  3,U         ; just clear the 2 lower bits of TOS
   STB   3,U
   ENDC

* make page and X points to the address in TOS (stack unmodified)
getAddr
   LDD   2,U         ; load lower part of the address
   ANDA  #$30        ; clear high bits
   ADDA  #$a0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X updated
   LDD   1,U         ; load 16kb page section of address

* updates page when neeeded
* D=high bytes of the 24bits address
updatePage
   ANDB  #$c0        ; just keep the 2 top bits
   CMPD  #page       ; compare wit current page index
page equ *-2         ; page index (dynamic code)
   BEQ   donePage    ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA '
* map proper bank onto $A000...$DFFF space
* A=bank number
chgBank
   STA   $e7e6       ; need to check, might use PIA instead
donePage
   RTS               ; done

* restore the page back to the instruction page
updatePC
   LDD  #PC_PG       ; load instruction page
PC_PG SET *-2        ; instruction page (dynamic code)
updatePC_D
   BSR  updatePage   ; update page if needed

* fetches and execute an instruction
fetch
   LDB   ,y+         ; load instruction byte
chkPC
   CMPY  #$E000      ; check page change
   BHS   decode      ; no => just decode inwtruction
   PSHS  B           ; preserve opcode
   LDD   <PC_PG      ; load PC page
   ADDD  #$40        ; adds 16kb
   STD   <PC_PG      ; update PC page
   BSR   updatePage  ; update bank
   LDY   #$A000      ; go to start of page
   PULS  B           ; restore opcode
decode
   LSLB              ; decode the opcode
   BCS   opIM        ; opcode=1xxxxxxx ? yes => immediate value
   BMI   opLDSTSP_x  ; opcode=01xxxxxx ? yes => LDsp_x or STsp_x
   LDX   #opTable
   JMP   [B,X]       ; jump to instruction

* COMmon part between opLD and opST depending on N flag
opLDSTSP_x
   LSLB              ; B ~ x*4
   BPL   opSTORESP_x
*  BRA   opLOADSP_x

***************************************
* Load on stack the value at stack[x]
* B=-xxxxx00 (4*x)
***************************************
opLOADSP_x
   ANDB  %01111100   ; clear bit 7 of 4*x
   LEAX  B,U         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHU  D,X         ; push 32 bits
   BRA   fetch       ; next instruction

* Write top of stack at stack[x]
* B=0xxxxx00 (4*x)
opSTORESP_x
   LEAX  B,U         ; X point to dest (bit7 already 0)
   LDD   ,U          ; load high word
   STD   ,X          ; store high word
   LDD   2,U         ; load low word
   STD   2,X         ; store low word
   LEAU  4,U         ; adjust the stack
   BRA   fetch       ; next instructio,

* Adds to TOS the value at stack[x]
* B=0--xxxx00 (4*x)
opADDSP_x
   LSRB              ; B ~ 4*x
   ANDB  %00111100   ; make 4*x postitive
   LEAX  B,U         ; X point to source
   LDD   2,X         ; load low word of source
   ADDD  2,U         ; add low word of TOS
   STD   2,U         ; store result to TOS (lower word)
   LDD   ,X         < ; load high word of source<<
   ADCB  1,U         ; add with carry the TOS (high word)
   ADCA  ,U          ; second byte
   STD   ,U          ; store result to TOS (high word)
   BRA   fetch       ; next instruction

opUNKNOWN

opBREAKPT
   BRA   opBREAKPT   ; do nothing (breakpoint)

opNOP
   BRA   fetch       ; do nothing

* Pushes stack address
opPUSHSP
   LDD   #0          ; stack address is $0000:9xxx
   LEAX  ,U          ; this should be mapped to
   PSHU  D,X         ; bank 0, $Dxxx
   BRA   fetch

opPUSHSPADD
   LDD   2,U
   LSLD
   LSLD
   LEAX  D,U
   LDD   #0          ; stack address is $0000:9xxx
   PSHU  D,X         ; bank 0, $Dxxx
   JMP   <fetch

***************************************
* ARITHMETIC
***************************************

opADD
   LEAU  4,U         ; add TOS with NOS
   LDD   2,U         ; load lower word of NOS
   ADDD  -2,U        ; adds lower word of TOS
   STD   2,U         ; store result to NOS lower part
   LDD   ,U          ; load NOS top word
   ADCB  -3,U        ; adds TOS top word
   ADCA  -4,U        ; with carry
   STD   ,U          ; store uppdr world result
   JMP   <fetch      ; next intruction

opSUB
   LEAU  4,U         ; add TOS with NOS
   LDD   2,U         ; load lower word of NOS
   SUBD  -2,U        ; adds lower word of TOS
   STD   2,U         ; store result to NOS lower part
   LDD   ,U          ; load NOS top word
   SBCB  -3,U        ; adds TOS top word
   SBCA  -4,U        ; with carry
   STD   ,U          ; store uppdr world result
   JMP   <fetch      ; next intruction

opMULT
   LDD   #0          ; clear upper word
   STD   -4,U        ; 0123
   LDA   3,U         ; 4567
   LDB   7,U
   MUL               ; compute byte #4
   STD   -2,U        ; 3+7
   LEAX  -3,U
   LDD   #$0108      ; compute byte #3
   BSR   MULT1       ; 2+7
   BSR   MULT1       ; 3+6
   LEAX  -4,U
   LDD   #$0008      ; compute byte #2
   BSR   MULT2       ; 1+7
   BSR   MULT2       ; 2+6
   BSR   MULT2       ; 3+5
   LDD   #$FF08      ; compute byte #1
   BSR   MULT3       ; 0+7
   BSR   MULT3       ; 1+6
   BSR   MULT3       ; 2+5
   BSR   MULT3       ; 3+4
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   ,U
   LDD   2,X
   STD   2,U
   JMP   <fetch
MULT1
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   BCC   MULT0
   INC   -1,X
MULT0
   PULS  D,PC
MULT2
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   PULS  D,PC
MULT3
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDB  ,X
   STB   ,X
   PULS  D,PC

opMULT16X16
   LDD   #0          ; clear upper word
   STD   -4,U        ; 0123
   LDA   3,U         ; 4567
   LDB   7,U
   MUL               ; compute byte #4
   STD   -2,U        ; 3+7
   LEAX  -3,U
   LDD   #$0108      ; compute byte #3
   BSR   MULT1       ; 2+7
   BSR   MULT1       ; 3+6
   LEAX  -4,U
   LDD   #$0008      ; compute byte #2
   BSR   MULT2       ; 2+6
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   ,U
   LDD   2,X
   STD   2,U
   JMP   <fetch

opNEG
   LEAX  ,U
   BSR   neg_x
   JMP   <fetch
neg_x
   LDD   #0
   SUBD  2,X
   STD   2,X
   LDD   #0
   BCC   neg_x1
   LDD   #-1
neg_x1
   SUBD  ,X
   STD   ,X
   RTS

opDIV
   CLR   ,-S            ; clear sign bit
   LEAX  ,U
   LDB   ,X
   BPL   opDIV1
   COM   ,S             ; negate sign
   BSR   neg_x          ; negate dividend
opDIV1
   LEAX  4,U
   LDB   ,X
   BPL   opDIV2
   COM   ,S             ; negate sign
   BSR   neg_x          ; negate divisor
opDIV2
   BSR   UDIV32
   LEAX  4,U
   LDD   ,U
   COMA
   COMB
   STD   ,X
   LDD   2,U
   COMA
   COMB
   STD   2,X
   LEAU  ,X             ; fix stack
   LDB   ,S+            ; test sign
   BPL   opDIV3         ; positive => no chg
   BSR   neg_x          ; negate result
opDIV3
   JMP   <fetch

opMOD
   LEAX  ,U
   LDB   ,X
   BPL   opMOD1
   BSR   neg_x          ; negate dividend
opMOD1
   LEAX  4,U
   LDB   ,X
   BPL   opMOD2
   BSR   neg_x          ; negate divisor
opMOD2
   BSR   UDIV32
   LEAU  4,U            ; fix stack
   LDD   -8,U
   STD   ,U
   LDD   -6,U
   STD   2,U
   JMP   <fetch

* https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder
UDIV32
   LDD   #0
   STD   -4,U           ; R=0
   STD   -2,U
   LDX   #32
UDIV32_1
   ROR   3,U            ; N = N<<1
   ROR   2,U
   ROR   1,U
   ROR   ,U             ; carry = N(i)
   LDD   -2,U
   RORB                 ; inject N(i)
   RORA
   STD   -2,U
   ROR   -3,U
   ROR   -4,U           ; R = {R<<1 | N(i)}
   SUBD  6,U            ; R-D (low)
   STD   -6,U           ; save temp
   LDD   -4,U
   SBCB  5,U
   SBCA  4,U            ; R-D (high)
   BCS   UDIV32_2       ; R-D<0 ? yes => no chg
   STD   -4,U           ; R = R-D (high)
   LDD   -6,U           ; retrieve temp
   STD   -2,U           ;     R-D (low)
UDIV32_2
   LEAX  -1,X
   BNE   UDIV32_1
   ROR   3,U            ; inject last comparison bit
   ROR   2,U
   ROR   1,U
   ROR   ,U
   RTS

***************************************
* LOGIC
***************************************

opAND
   LDD   ,U          ; bitwise "and" of TOS with NOS
   LEAU  4,U
   ANDA  ,U
   ANDB  1,U
   STD   ,U
   LDD   -2,U
   ANDA  2,U
   ANDB  3,U
   STD   2,U
   JMP   <fetch

opOR
   LDD   ,U          ; bitwise "or" of TOS with NOS
   LEAU  4,U
   ORA   ,U
   ORB   1,U
   STD   ,U
   LDD   -2,U
   ORA   2,U
   ORB   3,U
   STD   2,U
   JMP   <fetch

opXOR
   LDD   ,U          ; bitwise "or" of TOS with NOS
   LEAU  4,U
   EORA  ,U
   EORB  1,U
   STD   ,U
   LDD   -2,U
   EORA  2,U
   EORB  3,U
   STD   2,U
   JMP   <fetch

opNOT
   COM   ,U          ; bitwise complement of TOS
   COM   1,U
   COM   2,U
   COM   3,U
   JMP   <fetch

flip2
   LSLA              ; helper to flip A and B bits
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ADCA  #0
   RTS

opFLIP
   LDA   ,U          ; flips the bits of tje TOS
   LDB   3,U
   BSR   flip2
   STA   ,U
   STB   3,U
   LDD   1,U
   BSR   flip2
   STD   1,U
   JMP   <fetch

opSWAP
   LDD   ,U
   LDX   2,U
   STX   ,U
   STD   2,U
   JMP   <fetch

***************************************
* MEMORY
***************************************

opLOADIO
   LDD   2,U
   CMPD  #12         ; UART
   BEQ   opLOADUART
   CMPD  #24         ; UART
   BEQ   opLOADUART
opLOADIO_end
   CLRA
   STD   2,U
   STA   1,U
   STA   ,U
   JMP   <fetch
opLOADUART
   JSR   $E806
   BRA   opLOADIO_end

opSTOREIO
   LDD   2,U
   CMPD  #12         ; UART
   BEQ   opSTOREUART
   CMPD  #24         ; UART
   BEQ   opSTOREUART
opSTOREIO_end
   LEAU  8,U         ; fixup stack
   JMP   <fetch
opSTOREUART
   LDB   7,U
   JSR   $E803
   BRA   opSTOREIO_end

opLOAD
   LDB   ,U          ; chk IO range
   BMI   opLOADIO    ; yes => io-specific
   JSR   <getAddrL   ; convert adress
   LDD   ,X          ; load high word
   STD   ,U          ; store in TOS
   LDD   2,X         ; load lower word
   STD   2,U         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction

opSTORE
   LDB   ,U          ; chk IO range
   BMI   opSTOREIO   ; yes => io-specific code
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   4,U
   STD   ,X
   LDD   6,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back

opPOPSP
   PULU  D,X         ; change SP with the value of TOS
   LEAU  ,X          ; presumably we just keep the lower part of the address
   JMP   <fetch

opLOADH
   JSR   <getAddr    ; loads 16 bits
   LDX   ,X
outX
   LDD   #0
   STX   2,U
   BPL   outXpos
   LDD   #-1
outXpos
   STD   ,U
   JMP   <updatePC

opSTOREH
   JSR   <getAddr    ; stores 16 bits
   LDD   2,U
   STD   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

opLOADB
   JSR   <getAddr    ; loads 8 bits
   LDB   ,X
   LDX   #0
   LEAX  B,X         ; sign extend
   BRA   outX

opSTOREB
   JSR   <getAddr    ; stores 8 bits
   LDB   7,U
   STB   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

***************************************
* COMPARISON
***************************************

opLESSTHAN
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BLT   outTRUE
   BGT   outFALSE
   LDD   -2,U
   SUBD  2,U
   BMI   outTRUE
outFALSE
   LDD   #0          ; writes 0 on top of stack
   STD   ,U
   STD   2,U
   JMP   <fetch

opLESSTHANOREQUAL
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BGT   outFALSE
   BLT   outTRUE
   LDD   -2,U
   SUBD  2,U
   BPL   outFALSE
outTRUE
   LDD   #0          ; write 1 on top of stack
   STD   ,U
   INCB
   STD   2,U
   JMP   <fetch

opULESSTHAN
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BLO   outTRUE
   BHI   outFALSE
   LDD   -2,U
   SUBD  2,U
   BMI   outTRUE
   BRA   outFALSE

opULESSTHANOREQUAL
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BHI   outFALSE
   BLO   outTRUE
   LDD   -2,U
   SUBD  2,U
   BHI   outFALSE
   BRA   outTRUE

opEQ
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BNE   outFALSE
   LDD   -2,U
   SUBD  2,U
   BNE   outFALSE
   BRA   outTRUE

opNEQ
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BNE   outTRUE
   LDD   -2,U
   SUBD  2,U
   BNE   outTRUE
   BRA   outFALSE

***************************************
* SHIFT
***************************************

LSHIFTRIGHT MACRO
   LSRA
   RORB
   ROR   1,U
   ROR   2,U
   ENDM

opLSHIFTRIGHT
   LEAU  4,U
   LDD   ,U
   BEQ   opLSHIFTRIGHT_
   LSR  -1,U
   BCC   opLSHIFTRIGHT2
   LSHIFTRIGHT
opLSHIFTRIGHT2
   LSR   -1,U
   BCC   opLSHIFTRIGHT4
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT4
   LSR   -1,U
   BCC   opLSHIFTRIGHT8
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT8
   STD   ,U
   LSR   -1,U
   BCC   opLSHIFTRIGHT16
   LDD   1,U
   STD   2,U
   CLRA
   LDB   ,U
   STD   ,U
opLSHIFTRIGHT16
   LSR   -1,U
   BCC   opLSHIFTRIGHT32
   LDD   ,U
   STD   2,U
   LDD   #0
   STD   ,U
opLSHIFTRIGHT32
   JMP   <fetch

LSRD  MACRO
   LSRA
   RORB
   ENDM

opLSHIFTRIGHT_
   LDD   2,U
   LSR  -1,U
   BCC   opLSHIFTRIGHT_2
   LSRD
opLSHIFTRIGHT_2
   LSR   -1,U
   BCC   opLSHIFTRIGHT_4
   LSRD
   LSRD
opLSHIFTRIGHT_4
   LSR   -1,U
   BCC   opLSHIFTRIGHT_8
   LSRD
   LSRD
   LSRD
   LSRD
opLSHIFTRIGHT_8
   LSR   -1,U
   BCC   opLSHIFTRIGHT_16
   TFR   A,B
   CLRA
opLSHIFTRIGHT_16
   LSR   -1,U
   BCC   opLSHIFTRIGHT_32
   LDD   #0
opLSHIFTRIGHT_32
   STD   2,U
   JMP   <fetch

ASHIFTLEFT MACRO
   LSLB
   ROLA
   ROL   1,U
   ROL   ,U
   ENDM

opASHIFTLEFT
   LEAU  4,U
   LDD   2,U
   BEQ   opASHIFTLEFT_
   LSR  -1,U
   BCC   opASHIFTLEFT2
   ASHIFTLEFT
opASHIFTLEFT2
   LSR  -1,U
   BCC   opASHIFTLEFT4
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT4
   LSR  -1,U
   BCC   opASHIFTLEFT8
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT8
   STD   2,U
   LSR  -1,U
   BCC   opASHIFTLEFT16
   LDD   1,U
   STD   ,U
   LDA   3,U
   CLRB
   STD   2,U
opASHIFTLEFT16
   LSR  -1,U
   BCC   opASHIFTLEFT32
   LDD   2,U
   STD   ,U
   LDD   #0
   STD   2,U
opASHIFTLEFT32
   JMP   <fetch

LSLD  MACRO
   LSLB
   ROLA
   ENDM

opASHIFTLEFT_
   LDD   ,U
   LSR  -1,U
   BCC   opASHIFTLEFT_2
   LSLD
opASHIFTLEFT_2
   LSR  -1,U
   BCC   opASHIFTLEFT_4
   LSLD
   LSLD
opASHIFTLEFT_4
   LSR  -1,U
   BCC   opASHIFTLEFT_8
   LSLD
   LSLD
   LSLD
   LSLD
opASHIFTLEFT_8
   LSR  -1,U
   BCC   opASHIFTLEFT_16
   TFR   B,A
   CLRB
opASHIFTLEFT_16
   LSR  -1,U
   BCC   opASHIFTLEFT_32
   LDD   #0
opASHIFTLEFT_32
   STD   ,U
   JMP   <fetch

ASHIFTRIGHT MACRO
   ASRA
   RORB
   ROR   1,U
   ROR   2,U
   ENDM

opASHIFTRIGHT
   LEAU  4,U
   LDD   ,U
   LSR  -1,U
   BCC   opASHIFTRIGHT2
   ASHIFTRIGHT
opASHIFTRIGHT2
   LSR   -1,U
   BCC   opASHIFTRIGHT4
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT4
   LSR   -1,U
   BCC   opASHIFTRIGHT8
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT8
   STD   ,U
   LSR   -1,U
   BCC   opASHIFTRIGHT16
   LDD   1,U
   STD   2,U
   LDB   ,U
   SEX
   STD   ,U
opASHIFTRIGHT16
   LSR   -1,U
   BCC   opASHIFTRIGHT32
   LDB   ,U
   SEX
   TFR   A,B
   STD   ,U
   STD   2,U
opASHIFTRIGHT32
   JMP   <fetch

***************************************
* CONTROL FLOW (PC RELATED)
***************************************


opEMULATE_x
   LSLB              ; B=01xx xxx0
   LSLB              ; B=1xxx xx00
   LSLB              ; B=xxxx x000
   CLRA              ; D=0000 0000 xxxx x000
   LSLD              ; D=0000 000x xxxx 0000
   LSLD              ; D=x*32
   TFR   D,X
   LDD   #0
   PSHU  D,X
   * BRA   opCALL

opCALL
   LDD   1,U
   ANDB  #$C0        ; clear lower bit
   TFR   D,X         ; saves PC_PG

   LDD   2,U         ; fix lower bits
   ANDA  #$3F
   ADDA  #$A0
   EXG   Y,D         ; update PC_REG

   ANDA  #$3F        ; clear upper bits of old PC
   ADDA  <PC_PG+1    ; add page lower bits
   STD   2,U         ; store lower word of PC
   LDB   <PC_PG      , load pages upper bits
   CLRA              ; PC is 24 bits
   STD   ,U          ; store upper word of PC

   STX   <PC_PG      ; update PC page
   JMP   <updatePC

opPOPPC
   LDD   2,U         ; lower word of PC
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ADDA  #$A0
   TFR   D,Y         ; update pc reg
   LDD   1,U         ; load page field
   ANDB  #$C0        ; align 16k
   STD   <PC_PG      ; upodate high word of PC
   LEAU  4,U         ; fixup stack
   JMP   <updatePC_D ; update page etc

doBRANCH
   LDD   ,U
   LEAU  4,U
   STD   ,U
   LDD   -2,U
   STD   2,U
   * fall through
opPOPPCREL
   bsr   addPCREL
   BRA   opPOPPC

addPCREL
   TFR   Y,D
   ANDA  #$3F
   ADDA  <PC_PG+1
   ADDD  2,U
   STD   2,U
   LDD   ,U
   ADCB  <PC_PG
   CLRA              ; 24 bits
   STD   ,U
   RTS

opCALLPCREL
   BSR   addPCREL
   BRA   opPOPPC

opEQBRANCH
   LDD   6,U
   BNE   noBRANCH
   LDD   4,U
   BEQ   doBRANCH
noBRANCH
   LEAU  8,U
   JMP   <fetch

opNEQBRANCH
   LDD   6,U
   BNE   doBRANCH
   LDD   4,U
   BNE   doBRANCH
   BRA   noBRANCH

opPUSHPC
   TFR   Y,D
   ANDA  #$3F
   ADDA  <PC_PG+1
   PSHS  D
   LDB  <PC_PG
   CLRA              ; 24 bits
   PSHS  D
   JMP   <fetch

***************************************
* INSTRUCTION TABLE
***************************************
opTable
   FDB   opBREAKPT            ;  0 %0000 0000
   FDB   opUNKNOWN            ;  1 %0000 0001
   FDB   opPUSHSP             ;  2 %0000 0010
   FDB   opUNKNOWN            ;  3 %0000 0011
   FDB   opPOPPC              ;  4 %0000 0100
   FDB   opADD                ;  5 %0000 0101
   FDB   opAND                ;  6 %0000 0110
   FDB   opOR                 ;  7 %0000 0111
   FDB   opLOAD               ;  8 %0000 1000
   FDB   opNOT                ;  9 %0000 1001
   FDB   opFLIP               ; 10 %0000 1010
   FDB   opNOP                ; 11 %0000 1011
   FDB   opSTORE              ; 12 %0000 1100
   FDB   opPOPSP              ; 13 %0000 1101
   FDB   opUNKNOWN            ; 14 %0000 1110
   FDB   opUNKNOWN            ; 15 %0000 1111

   FDB   opADDSP_x            ; 16 %0001 0000
   FDB   opADDSP_x            ; 17 %0001 0001
   FDB   opADDSP_x            ; 18 %0001 0010
   FDB   opADDSP_x            ; 19 %0001 0011
   FDB   opADDSP_x            ; 20 %0001 0100
   FDB   opADDSP_x            ; 21 %0001 0101
   FDB   opADDSP_x            ; 22 %0001 0110
   FDB   opADDSP_x            ; 23 %0001 0111
   FDB   opADDSP_x            ; 24 %0001 1000
   FDB   opADDSP_x            ; 25 %0001 1001
   FDB   opADDSP_x            ; 26 %0001 1010
   FDB   opADDSP_x            ; 27 %0001 1011
   FDB   opADDSP_x            ; 28 %0001 1100
   FDB   opADDSP_x            ; 29 %0001 1101
   FDB   opADDSP_x            ; 30 %0001 1110
   FDB   opADDSP_x            ; 31 %0001 1111

   FDB   opEMULATE_x          ; 32 %0010 0000
   FDB   opUNKNOWN            ; 33 %0010 0001
   FDB   opLOADH              ; 34 %0010 0010
   FDB   opSTOREH             ; 35 %0010 0011
   FDB   opLESSTHAN           ; 36 %0010 0100
   FDB   opLESSTHANOREQUAL    ; 37 %0010 0101
   FDB   opULESSTHAN          ; 38 %0010 0110
   FDB   opULESSTHANOREQUAL   ; 39 %0010 0111
   FDB   opSWAP               ; 40 %0010 1000
   FDB   opMULT               ; 41 %0010 1001
   FDB   opLSHIFTRIGHT        ; 42 %0010 1010
   FDB   opASHIFTLEFT         ; 43 %0010 1011
   FDB   opASHIFTRIGHT        ; 44 %0010 1100
   FDB   opCALL               ; 45 %0010 1101
   FDB   opEQ                 ; 46 %0010 1110
   FDB   opNEQ                ; 47 %0010 1111

   FDB   opNEG                ; 48 %0011 0000
   FDB   opSUB                ; 49 %0011 0001
   FDB   opXOR                ; 50 %0011 0010
   FDB   opLOADB              ; 52 %0011 0011
   FDB   opSTOREB             ; 52 %0011 0100
   FDB   opDIV                ; 53 %0011 0101
   FDB   opMOD                ; 54 %0011 0110
   FDB   opEQBRANCH           ; 55 %0011 0111
   FDB   opNEQBRANCH          ; 56 %0011 1000
   FDB   opPOPPCREL           ; 57 %0011 1001
   FDB   opEMULATE_x          ; 58 %0011 1010 opCONFIG
   FDB   opPUSHPC             ; 59 %0011 1011
   FDB   opEMULATE_x          ; 60 %0011 1100 opSYSCALL
   FDB   opPUSHSPADD          ; 61 %0011 1101
   FDB   opMULT16X16          ; 62 %0011 1110
   FDB   opCALLPCREL          ; 63 %0011 1111

(info)
   END
