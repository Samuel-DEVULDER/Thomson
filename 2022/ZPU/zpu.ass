(main)zpu
   ORG   $7000
   
   

SAFE        SET   0           ; force long addressing for long ops (slower)
LPR         SET   0           ; also output result to printer on parallel port
TRACE       SET   0           ; traces executed instructions
CYCLE_TIMER SET   0           ; timer based on cycle (costly) or rtc (accurate) ?
FUSE        SET   1           ; fuses frequent sequences of isntructions into a big one
SMALL_BRNCH SET   1           ; optimizes 8-bits branches

FIRST_PAGE  SET   2           ; address 0 is mapped to that page
STACK_SIZE  SET   2048        ; size of stack
IO_SPACE    SET   $0800       ; address above IO_SPACE:00000 are IO related (value chosen for Phi board)
STK_SPACE   SET   IO_SPACE-1  ; high word of unmapped zone (make sure it is below IO_SPACE)

***************************************
* System equates
***************************************
PUTC  EQU   $E803             ; prints a char
GETC  EQU   $E806             ; reads the keybord
RSOPC EQU   $602B             ; serial/parallel command
RSCO  EQU   $E812             ; serial/parallel execute
LGA5  EQU   $E7E5             ; reg for memory bank at $A000-$DFFF
LGA6  EQU   $E7E6             ; reg for memory bank at $0000-$3FFF
LGA7  EQU   $E7E7             ; Gate Array "mode page"

COLOR MACRO
  IFEQ  LPR
   FCB   27,$40+\0
  ENDC
   ENDM

ASRD  MACRO
   ASRA
   RORB
   ENDM

LSRD  MACRO
   LSRA
   RORB
   ENDM

LSLD  MACRO
   LSLB
   ROLA
   ENDM

main
   LEAS  main,PCR
   
* SETS DP
   LDA   #PAGE0
   TFR   A,DP
   SETDP PAGE0
   
   JSR   INITTTY
   
* DETERMINE BANKING ALGORITHM
   LDB   >$FFF0
   CMPB  #3          ; B>=3 for new machines
   LDD   #$200D      ; A="BRA COMMUT"; CARRY unchanged.
   BLO   SET_BANKALG 
   LDA   #$10
   ORA   >$6081      ; Activate
   STA   >$6081      ; direct
   STA   >LGA7       ; RAM
   LDD   #$8B00+FIRST_PAGE ; A="ADDA #FIRST_PAGE"
   STD   <updatePageBank
SET_BANKALG
   STD   <BANK
   BSR   INITMEMORY

   LDX   #FILENAME
   JSR   LOADFILE

   JSR   INITTIMER
GOZPU
* CONFIGURE ROM sentinel
   LDA   >$E000      ; $E00 sentinel
   BPL   okROM
   JSR   PUTSTR
   FCC   /ERROR ROM BYTE @$E000 < /
   FCB   128+'0
   SWI
   BRA   *
okROM SET *
   LDX   #opTable
   LSLA
   LEAX  A,X
   LDD   ,X
   STD   <outOfPageChk2
   LDD   #outOfPageChk
   STD   ,X
* init CPU
   LDU   #opTable
   LDS   #$A000-8
   STS   <page       ; force page to be out of address space
   LDD   #0
   LDX   #0
   PSHS  D,X         ; push address $0000 0000
   JMP   opPOPPC     ; and off we go

***************************************
* MEMORY
***************************************
LAST_PAGE
   FCB   0

INITMEMORY
   BSR   FINDMAX        ; guess LAST_PAGE
   BSR   PRINTMAX       ; prints a message about it
   LDA   LAST_PAGE      ; clear all banks starting from the last one
CLRPAGES
   JSR   <BANK          ; update bank
   BSR   CLRPAGE        ; no => clear $A000..$DFFF
   DECA                 ; next page
   BNE   CLRPAGES
   JSR   <BANK          ; update bank
* CLEAR FAT-$A000  = stack space"
   LDX   #FAT
CLRSTACK
   STA    ,X+       
   CMPX   #$A000
   BNE    CLRSTACK
* CLEAR $A000-$DFFF
CLRPAGE
   PSHS  D,X,Y,U,DP,CC       ; clears a memory zone upto $E000
   ORCC  #$50
   STS   CLRPAGE2
   LDD   #0
   TFR   B,DP
   TFR   D,X
   LEAY  ,X
   LEAU  ,X
   LDS   #$E000
CLRPAGE1
   PSHS  DP,A,X,Y,U           ; 16ko = 8 x 8 x 256
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   PSHS  DP,A,X,Y,U
   DECB
   BNE   CLRPAGE1
   LDS   #0
CLRPAGE2 SET *-2
   PULS  D,X,Y,U,DP,CC,PC

FINDMAX
   PSHS  D,X,U          ; find maximum page (LAST_PAGE)
   LDX   #256*'N+'K
   LDU   #$A000
   LDD   #$FF00+'B
FINDMAX1
   INCA
   CMPA  #$20-FIRST_PAGE
   BEQ   FINDMAX3
   JSR   <BANK
   CMPX  2,U
   BNE   FINDMAX2
   CMPB  1,U
   BEQ   FINDMAX3
FINDMAX2
   STD   ,U
   CMPD  ,U
   BNE   FINDMAX3
   STX   2,U
   CMPX  2,U
   BEQ   FINDMAX1
FINDMAX3
   DECA
   STA   LAST_PAGE
   PULS  D,X,U,PC

PRINTMAX
   PSHS  D
   JSR   PUTSTR
   FCB   12
   FCC   /Found/
   FCB   128+32
   LDB   LAST_PAGE
   INCB
   JSR   DECIMAL
   JSR   PUTSTR
   FCC   /x16k free memory/
   FCB   13,10+128
   PULS  D,PC

INITTTY
*   JSR   $E800
   LDD   #$A559
   STD   >$60FE
   LDX   #INITTTY_lores
* change palette
   LDA   >$FFF0
   CMPA  #2
   BLO   NOTTYPAL
   LDX   #$E7DA
   LDD   #0
   STB   1,X
   LDD   #$FF0
   STB   ,X
   STA   ,X
   LDD   #$F00
   STB   ,X
   STA   ,X
   LDX   #INITTTY_hires
NOTTYPAL
   LDB   ,X+
INITTTY1
   JSR   >$E803
   LDB   ,X+
   BNE   INITTTY1
   IFNE  LPR         ; open parallel port
   LDB   #$40
   STB   >RSOPC
   JSR   >RSCO
   LDB   #$08        ; to write bytes
   STB   >RSOPC
   ENDC
   LDB   #12
   JMP   PUTCHAR
INITTTY_hires
   FCB   $1B,$5B     ; 80x25
   FCB   $1B,$66     ; BD=MAGENTA 
   FCB   $11,0       ; CURSOR ON

INITTTY_lores
   FCB   $1B,$44     ; FG=BLUE
   FCB   $1B,$56     ; BG=MAGENTA
   FCB   $1B,$66     ; BD=MAGENTA 
   FCB   $0C         ; CLS
   FCB   $1B,$68     ; COLOR OFF
   FCB   $11,0       ; CURSOR ON

PUTS
   PSHS  B        ; prints a 0 or neg-terminated string pointed by X (updated)
   BRA   PUTS1
PUTS0
   BSR   PUTCHAR
PUTS1
   LDB   ,X+
   BEQ   PUTS2
   BPL   PUTS0
   ANDB  #127
   BSR   PUTCHAR
PUTS2
   PULS  B,PC

PUTSTR
   PSHS  X           ; prints the string follwing the call
   LDX   2,S
   BSR   PUTS
   STX   2,S
   PULS  X,PC

HEX32
   BSR   HEX16       ; prints 32 bits value at X (incremented)
HEX16
   BSR   HEX8        ; prints 16 bits value at X (incremented)
HEX8
   LDB   ,X+         ; prints 8 bits value at X (incremented)
   * BRA   HEX
HEX
   BSR   HEX0        ; print B in hexa (A trashed)
   EXG   A,B
HEX0
   LDA   #$10
   MUL
   ADDA  #$90
   DAA
   ADCA  #$40
   DAA
   EXG   A,B
PUTCHAR
  IFNE  LPR
   IFEQ  TRACE
   JSR   PUTC
   ENDC
   JMP   RSCO
  ELSE
   JMP   PUTC              ; prints a character (in B)
  ENDC

DECIMAL
   STB   ,-S               ; prints a signed byte in decimal
   BPL   DECIMAL1
   NEG   ,S
   BSR   PUTSTR
   FCB   128+'-
DECIMAL1
   CLRA
   LDB   #8
DECIMAL2
   LSL   ,S
   STA   ,-S
   ADCA  ,S+
   DAA
   DECB
   BNE   DECIMAL2
   STA   ,S
   BCC   DECIMAL3
   BSR   PUTSTR
   FCB   128+'1
   LDB   ,S+
   BRA   HEX8
DECIMAL3
   LDB   ,S
   LSRB
   LSRB
   LSRB
   LSRB
   BEQ   DECIMAL4
   ADDB  #'0
   BSR   PUTCHAR
DECIMAL4
   LDB   ,S+
   ANDB  #15
   ADDB  #'0
   BRA   PUTCHAR

LOADFILE
   PSHS  A,X,U
   BSR   PUTSTR
   FCC   /Loading/
   FCB   32+128
   BSR   PRINTFN
   BSR   PUTSTR
   FCC   /../
   FCB   128+'.
   LDX   1,S
   CLRA 
   LDU   #$A000
   BSR   LOAD
   BSR   PUTSTR
   FCC   /done/
   FCB   13,10,13,10+128
   PULS  A,X,U,PC
PRINTFN
   PSHS  D,X,U
   LDA   #8
   LDB   1,X
   CMPB  #':
   BNE   PRINTFN1
   ADDA  #2
PRINTFN1
   LEAU  A,X
PRINTFN2
   DECA
   BMI   PRINTFN3
   LDB   A,X
   CMPB  #32
   BEQ   PRINTFN2
   INCA
   BSR   PRINTFN4
PRINTFN3
   LEAX  ,U
   LDD   #3*256+'.
   JSR   PUTCHAR
   BSR   PRINTFN4
   PULS  D,X,U,PC
PRINTFN4
   LDB   ,X+
   JSR   PUTCHAR
   DECA
   BNE   PRINTFN4
   RTS

*--------------------------------------*|*
  * Module de chargement pour un fichier *
  * Entrees:                             *
  * A = BANK                             *
  * X = Pointeur sur nom de fichier      *
  * U = Adresse d'implantation           *
  *--------------------------------------*
*DKOPC equ    $6048  ; operation d7
DKDRV EQU   $6049    ; lecteur
DKTRK EQU   $604A    ; piste (2 ocets)
DKSEC EQU   $604C    ; secteur
DKSTA EQU   $604E    ; status d7
DKBUF EQU   $604F    ; buf i/o
DKCAT EQU   $60E9    ; ptr catalogue
DKNAM EQU   $60E7    ; nom fichier
DKTYP EQU   $60EB    ; type fichier (2octets)
DKFAT EQU   $60ED    ; ptr fat
DKMOD EQU   $60F0    ; mode d'acces
DKFIN EQU   $60F3    ; dernier bloc
DKBLK EQU   $60F6    ; 1er bloc fichier
DKTDS EQU   $60F7    ; nb octets dern sect (2octets)
DKIFA EQU   $60F9    ; secteur fat fichier
LECFA EQU   $E00D    ; lecture fat
RECFI EQU   $E010    ; recherche fichier
CONVB EQU   $E01F    ; converison bloc
DKCOM EQU   $E82A    ; commande d7

LOAD
   PSHS  D,X,U,DP    ; Load a file from minidos
   PSHS  A           ; set BANK cpt
   JSR   <BANK       ; set bank
   SETDP $60
   LDD   #$6000
   TFR   A,DP
   STB   DKDRV
   LDA   1,X
   CMPA  #':
   BNE   LOAD00
   LDA   ,X++
   SUBA  #'0
   STA   DKDRV
LOAD00
   LDA   #$02     A=2, B=$00
   STB   DKSTA    Efface erreur
   STB   $6025   ; FIX COPBUF
   STD   DKTYP    Type de fichier
   STX   DKNAM    Nom du fichier
   STU   LDPTR    Adr d'implantation
* Chargement de la FAT
   LDX   #BUF
   STX   DKCAT
   LDX   #FAT
   STX   DKFAT
   JSR   LECFA    Charge la FAT
   BCS   ERRIO    Si "I/O Error"
* Recherche du fichier
   LDA   #1       | Initialise
   STA   DKMOD    | en LOAD
   JSR   RECFI    Recherche fichier
   TST   DKIFA    | Si $60F9 = 0,
   BEQ   ERRNF    | fich non trouve'
* Convertit numero de bloc
LOAD0
   JSR   CONVB    Convertit bloc
   STB   DKTRK+1  Initialise piste
   LDX   DKFAT    Pointeur sur FAT
   LDB   DKBLK    Bloc courant
   INCB           | Bloc
   LDB   B,X      | suivant
   STB   DKBLK    Sauve le bloc
   CMPB  #$C0     | Si dernier bloc,
   BHI   LOAD1    | recupere taille
   LDB   #$08     8 secteurs a charg
LOAD1
   ANDB  #$0F     Isole taille bloc
   STA   DKSEC    Sauve premier bloc
   ADDB  DKSEC    Ajoute depart bloc
   DECB           Ajuste dern bloc
   STB   DKFIN    Sauve dernier bloc
* Charge les secteurs
LOAD2
   JSR   DKCOM    Charge le secteur
   BCS   ERRIO    Si "I/O Error"
   LDA   $604C    | Si secteur pas
   CMPA  DKFIN    | secteur maximum,
   BNE   LOAD3    | passe
   LDA   DKBLK    | Si dernier
   CMPA  #$C0     | secteur du
   BHI   LOAD4    | fichier, sort
   BSR   TFR      Transfere donnees
   BRA   LOAD0    Bloc suivant
LOAD3
   BSR   TFR      Transfere donnees
   INC   $604C    Secteur + 1
   BRA   LOAD2    Secteur suivant
* Chargement dernier secteur et sortie
LOAD4
   LDD   DKTDS    Taille dern sect
   BEQ   LOAD5    Si 0, sort
   BSR   TFR0     Transfere donnees
LOAD5
   CLRA           efface carry
LOAD6
   LDD   ,S+      ; fixe cpt BANK
   TFR   B,A
   JSR   >BANK    ; restore init BANK
   PULS  D,X,U,DP,PC
ERRIO
   JSR   PUTSTR
   FCB   13,10
   FCC   /IO ERROR/
   FCB   7+128
ERRLOOP
   BRA   ERRLOOP
ERRNF
   JSR   PUTSTR
   FCB   13,10
   FCC   /FILE NOT FOUND/
   FCB   7+128
   BRA   ERRLOOP
ERROM
   LEAS  2,S
   JSR   PUTSTR
   FCB   13,10
   FCC   /OUT OF MEMORY/
   FCB   7+128
   BRA   ERRLOOP
* Transfert des donnees
TFR
   LDB   $6058   | Ajuste taille
   COMB          | maximum du
   ORB   #$80    | secteur
TFR0
   LDX   #0      Recupere ptr mem
LDPTR SET   *-2
   LEAU  ,X
   ABX
   CMPX  #$E000
   LEAX  ,U
   LDU   DKBUF   Ptr buffer secteur
   BCC   TFRslow

TFRfast
   LDA   ,U+     |
   STA   ,X+     | Transfere
   DECB          | les donnees
   BNE   TFRfast |
TFR1
   STX   LDPTR   Sauve implantation
   RTS
   
TFRslow
   LDA   ,U+     |
   STA   ,X+     | Transfere
   CMPX  #$E000
   BNE   TFRslow2
   
   LDX   #$A000
   LDA   3,S
   INCA
   CMPA  LAST_PAGE
   BHI   ERROM
   JSR   >BANK   
TFRslow2
   DECB          | les donnees
   BNE   TFRslow |
   BRA   TFR1

   SETDP 0

***************************************
* Timer
***************************************
TIMEPT   EQU   $6027
STATUS   EQU   $6019
IRQPT    EQU   $6021
KBIN     EQU   $E830

TIMER_CTR
   FDB   0        ; timer counter (64 bits)
   FDB   0
   FDB   0
   FDB   0

INITTIMER
   PSHS  D,X      ; init timer
   ORCC  #$50
   LDD   #0
   LDX   #0
   LDU   #TIMER_CTR+8
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
  IFEQ  CYCLE_TIMER
   LDA   STATUS
   ORA   #%00100100
   STA   STATUS
   LDX   #TIMERINTER
   STX   TIMEPT
*   STX   IRQPT
  ENDC
   ANDCC #$AF
   PULS  D,X,PC

* 100 ms = 100 000 us
*        = $1 86A0
   IFNE  CYCLE_TIMER
TINC2 SET 0
TINC1 SET 1
   ELSE
TINC2 SET $1
TINC1 SET $86A0
   ENDC
TIMERINTER
   IFNE  CYCLE_TIMER
   PSHS  D,X
   ENDC
   LDX   #TIMER_CTR+4
   LDD   #TINC1
   ADDD  2,X
   STD   2,X
   LDD   ,X
   ADCB  #TINC2
   ADCA  #0
   STD   ,X
   BCC   TIMERINTERX
   LDD   -2,X
   ADCB  #0
   ADCA  #0
   STD   -2,X
   BCC   TIMERINTERX
   LDD   -4,X
   ADCB  #0
   ADCA  #0
   STD   -4,X
TIMERINTERX
   IFNE  CYCLE_TIMER
   PULS  D,X,PC
   ELSE
   JMP   KBIN
   ENDC

   ORG   ((*+255)/256)*256
PAGE0   SET   */256
   SETDP PAGE0
   
***************************************
* Changes bank at $A000 
* A = bank number
***************************************
BANK
   BRA   COMMUT    ; will becomle CMPA #nn on TO8+
*   ADDA  #FIRST_PAGE
   STA   >LGA5
   SUBA  #FIRST_PAGE
   RTS
   FCB   $0F,$17,$E7,$67,$A7,$27,$0F
COMMUT
   PSHS  D,U 
   LDU   #COMMUT-7 ; U pointe sur l'adresse de la table des valeurs a mettre dans le PLA 
   LDA   A,U       ; Lecture de la valeur de la table 
   LDU   #$E7CB
   LDB   ,U        ; Lecture du registre CRB en E7CB 
   ANDB  #$FB      ; Passage du PIA en mode direction 
   STB   ,U   
   STA   -2,U      ; Modifications des directions ecriture dans le DDRB du PIA en E7C9 
   ORB   #$04      ; Passage du PIA en mode donnees 
   STB   ,U        ; (retour aux conditions depart) 
   PULS  D,U,PC  ; Retour  

FETCH_INSTRUCTION MACRO
   IFNE  TRACE
   JSR   doTRACE
   ENDC
   LDB   ,Y+         ; fetch next instruction code
   ENDM

* SAFE version of getAddr for long values
getAddrL
   IFNE  SAFE
   LDB   #%11111100
   ANDB  3+2,S       ; just clear the 2 lower bits of TOS
   STB   3+2,S
   ENDC

* make page and X points to the address in TOS (stack unmodified)
getAddr
   LDA   2+0,S       ; speedup: if nul then adress is mapped
   BEQ   getAddrMapped
   LDX   2+2,S
   RTS
getAddrMapped
   LDD   2+2,S       ; load lower part of the address
   ANDA  #$3F        ; clear high bits
   ADDA  #$A0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X updated
   LDD   2+1,S       ; load 16kb page section of address
   ANDB  #$C0        ; just keep the 2 top bits

* updates page when neeeded
* D=high bytes of the 24bits address
updatePage
   CMPD  #page       ; compare with current page index
page equ *-2         ; page index (dynamic code)
   BEQ   donePage    ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA
updatePageBank
   JMP   <BANK
*   ADDA  #FIRST_PAGE
   STA   >LGA5
donePage
   RTS               ; done

  IFNE CYCLE_TIMER
decode_pos SET decode
  ELSE
decode_pos SET decode_
  ENDC
  
* FUSE opIM_x opPUSHSPADD opPOPSP

opIM
   BITB  #%01000000  ; [2]
   BEQ   opIMpos     ; [3]
   LDX   #$FF00      ; [3]
   ABX               ; [3]
   LDD   #-1         ; [3]
   PSHS  D,X         ; [9] = [23]
   FETCH_INSTRUCTION
   BPL decode_
   BRA   opIM2
opIMpos
   LDX   #$FF80      ; [3]
   ABX               ; [3]
   LDD   #0          ; [3]
   PSHS  D,X         ; [9] = [23]
   FETCH_INSTRUCTION
   BPL decode_

opIM2
   LSLB
   LDA   3,S
   ASRA
   RORB
   STD   2,S

   FETCH_INSTRUCTION
   BPL   decode_pos

opIM3
   LSLB
   LDA   2,S
   ASRA
   STA   1,S
   LDA   3,S
   RORA
   RORB
   STD   2,S

   FETCH_INSTRUCTION
   BPL   decode_pos

* loads a continuated immediate value
* B=xxxxxxx0 (value*2)
opIM_loop
   LSLB
   LSR    ,S         ; rotate TOS 7 bits left and add B/2 at the bottom
   LDA    1,S
   RORA
   STA    ,S         ; byte 0 is byte 1 rotated right once
   LDA    2,S
   RORA
   STA    1,S        ; byte 1 is byte 2 rotated right once
   LDA    3,S
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   STD    2,S        ; write lower word

   FETCH_INSTRUCTION
   BMI   opIM_loop
   BRA   decode_pos

* restore the page back to the instruction page
updatePC
   LDD  #PC_PG       ; load instruction page
PC_PG SET *-2        ; instruction page (dynamic code)
updatePC_D
   JSR  <updatePage  ; update page if needed
   
NEXT MACRO
  IFNE 0
    JMP  <fetch      ; -- 397 --> 389s
  ELSE
   FETCH_INSTRUCTION
  IFNE  CYCLE_TIMER
   JSR   TIMERINTER
  ENDC
   BMI   *+5
   LSLB              ; decode the opcode
   JMP   [B,U]       ; jump to instruction
   JMP   <opIM
  ENDC
  ENDM

* fetches and execute an instruction
opNOP
fetch
   FETCH_INSTRUCTION
decode
  IFNE  CYCLE_TIMER
   JSR   TIMERINTER
  ENDC
   BMI   opIM        ; opcode=1xxxxxxx ? yes => immediate value
decode_
   LSLB              ; decode the opcode
   JMP   [B,U]       ; jump to instruction

* handler for opcode out of page   
outOfPageChk
   CMPY  #$E000      ; check ROM ?
   BHS   nextPage    ; yes => next 16k page
   JMP   >opBREAKPT  : no => real implem
outOfPageChk2 SET *-2
nextPage
   LDD   <PC_PG      ; load PC page
   ADDD  #$40        ; adds 16kb
   STD   <PC_PG      ; update PC page
   JSR   <updatePage ; update BANk
   LDY   #$A000      ; go to start of page
   BRA   fetch
  
sampledTMR
   FDB   0,0,0,0     ; sampled timer

***************************************
* ARITHMETIC
***************************************

opSUB
   LEAX  ,S
   BSR   neg_x
   * BRA   opADD

* FUSE opADD opSTORESP_x

opADD
   LDD   ,S++
   BEQ   opADD1
   ADDD  2,S
   STD   2,S
opADD1
   PULS  D
   ADDD  2,S
   STD   2,S
   BCC   fetch
   INC   1,S
   BNE   fetch
   INC   ,S
opADD2
   BRA   fetch

neg_x
   LDD   #0
   SUBD  2,X
   STD   2,X
   LDD   #0
   BCC   neg_x1
   LDD   #-1
neg_x1
   SUBD  ,X
   STD   ,X
   RTS

opNEG
   LEAX  ,S
   BSR   neg_x
   NEXT
   
opDIV
   LEAX  ,S             ; X = ptr to dividend
   LEAS  -7,S           ; get space for UDIV32 sign+tmp16+mod32=1+2+4=7
   LDB   ,X
   STB   ,S
   BPL   opDIV1
   JSR   <neg_x         ; negate dividend
opDIV1
   LDB   4,X
   BPL   opDIV2
   COM   ,S             ; negate sign
   LEAX  4,X
   JSR   <neg_x         ; negate divisor
opDIV2
   BSR   UDIV32
   LDD   7,S
   COMA
   COMB
   STD   ,X
   LDD   7+2,S
   COMA
   COMB
opDIV4
   STD   2,X
   LDB   ,S             ; test sign
   LEAS  ,X             ; restore stack
   BPL   opDIV3         ; positive => no chg
   JSR   <neg_x         ; negate result
opDIV3
   JMP   <fetch

opMOD
   LEAX  ,S             ; X = ptr to dividend
   LEAS  -7,S           ; get space for UDIV32 sign+tmp16+mod32=1+2+4=7
   LDB   ,X
   STB   ,S             ; store sign
   BPL   opMOD1
   JSR   <neg_x         ; negate dividend
opMOD1
   LDB   4,X
   BPL   opMOD2
   LEAX  4,X
   JSR   <neg_x         ; negate divisor
opMOD2
   BSR   UDIV32
   LDD   3,S
   STD   ,X
   LDD   5,S
   BRA   opDIV4

* https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder
* stack: PC16 SGN TMP16 R32 N32 D32
UDIV_T SET 3
UDIV_R SET 5
UDIV_N SET 9
UDIV_D SET 13

UDIV32
   LDD   #0
   STD   UDIV_R,S       ; R=0
   STD   UDIV_R+2,S
   LDX   #32
UDIV32_1
   ROL   UDIV_N+3,S     ; N = N<<1
   ROL   UDIV_N+2,S
   ROL   UDIV_N+1,S
   ROL   UDIV_N+0,S     ; carry = N(i)
   LDD   UDIV_R+2,S
   ROLB                 ; inject N(i)
   ROLA
   STD   UDIV_R+2,S
   ROL   UDIV_R+1,S
   ROL   UDIV_R+0,S     ; R = {R<<1 | N(i)}
   SUBD  UDIV_D+2,S     ; R-D (low)
   STD   UDIV_T,S       ; save temp
   LDD   UDIV_R,S
   SBCB  UDIV_D+1,S
   SBCA  UDIV_D+0,S     ; R-D (high)
   BCS   UDIV32_2       ; R-D<0 ? yes => no chg
   STD   UDIV_R,S       ; R = R-D (high)
   LDD   UDIV_T,S       ; retrieve temp
   STD   UDIV_R+2,S     ;     R-D (low)
UDIV32_2
   LEAX  -1,X
   BNE   UDIV32_1
   ROL   UDIV_N+3,S        ; inject last comparison bit
   ROL   UDIV_N+2,S
   ROL   UDIV_N+1,S
   ROL   UDIV_N+0,S
   LEAX  UDIV_D,S
   RTS

* stack: pc16 reg32 [b0 b1 b2 b3].[b4 b5 b6 b7]

M07 EQU  (6+0)*256+(6+7)
M17 EQU  (6+1)*256+(6+7)
M27 EQU  (6+2)*256+(6+7)
M16 EQU  (6+1)*256+(6+6)
M26 EQU  (6+6)*256+(6+2)
M36 EQU  (6+6)*256+(6+3)
M25 EQU  (6+5)*256+(6+2)
M34 EQU  (6+4)*256+(6+3)
M35 EQU  (6+5)*256+(6+3)

opMULT
   LEAS  -4,S
   LDD   #0          ; clear upper word
   STD   ,S
   LDA   4+3,S
   LDB   4+7,S       ; compute byte #4
   MUL               ; 3+7
   STD   2,S
   LEAX  1,S         ; compute byte #3
   LDD   #M27        ; 2+7
   BSR   MULT1
   LDD   #M36        ; 3+6
   BSR   MULT1
   LEAX  ,S          ; compute byte #2
   LDD   #M17        ; 1+7
   BSR   MULT2
   LDD   #M26        ; 2+6
   BSR   MULT2
   LDD   #M35        ; 3+5
   BSR   MULT2
   LDD   #M07        ; compute byte #1
   BSR   MULT3       ; 0+7
   LDD   #M16
   BSR   MULT3       ; 1+6
   LDD   #M25
   BSR   MULT3       ; 2+5
   LDD   #M34
   BSR   MULT3       ; 3+4
MULCPY
   LEAX  4+4,S
   LDD   ,S          ; copy result to TOS
   STD   ,X
   LDD   2,S
   STD   2,X
   LEAS  ,X
   JMP   <fetch
MULT1
   LDA   A,S
   BEQ   MULT0
   LDB   B,S
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   BCC   MULT0
   INC   -1,X
MULT0
   RTS
MULT2
   LDA   A,S
   BEQ   MULT0
   LDB   B,S
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   RTS
MULT3
   LDA   A,S
   BEQ   MULT0
   LDB   B,S
   BEQ   MULT0
   MUL
   ADDB  ,X
   STB   ,X
   RTS

opMULT16X16
   LEAS  -4,S
   LDD   #0          ; clear upper word
   STD   ,S          ; 2301
   LDA   4+3,S       ; 6745
   LDB   4+7,S
   MUL               ; compute byte #4
   STD   2,S         ; 3+7
   LEAX  1,S
   LDD   #M27        ; compute byte #3
   BSR   MULT1       ; 2+7
   LDD   #M36        ; 3+6
   BSR   MULT1
   LEAX  ,S
   LDD   #M26        ; compute byte #2
   BSR   MULT2       ; 2+6
   BRA   MULCPY      ; copy result to TOS

***************************************
* Load on stack the value at stack[x]
* B=--xxxxx0 (2*x)
***************************************

opLOADSP_0
  IFNE FUSE
* opLOASP_0 opIM_x opADD  404s --> 397s (-0.98%)
   LDD   ,Y
   BPL   opLOADSP_0x
   CMPB  #5
   BNE   opLOADSP_0x
   LDX   ,S
   LDB   2,S
   LSLA
   ASRA
   BPL   opLOADSP_0p
   DECB
   LEAX  -1,X
opLOADSP_0p
   ADDA  3,S
   BCC   opLOADSP_0nx
   INCB
   BNE   opLOADSP_0nx
   LEAX  1,X
opLOADSP_0nx
   LEAY  2,Y
   STA   ,-S
   STB   ,-S
   PSHS  X
   NEXT
opLOADSP_0x
  ENDC
  
   LDD   ,S
   LDX   2,S
   PSHS  D,X
   NEXT

opLOADSP_ MACRO
opLOADSP_\0
   LDD   4*\0,S
   LDX   4*\0+2,S
   PSHS  D,X
   NEXT
   ENDM

   opLOADSP_ 1
   opLOADSP_ 2
   opLOADSP_ 3
   opLOADSP_ 4
   opLOADSP_ 5
   opLOADSP_ 6
   opLOADSP_ 7
   opLOADSP_ 8
   opLOADSP_ 9
   opLOADSP_ 10
   opLOADSP_ 11
   opLOADSP_ 12
   opLOADSP_ 13
   opLOADSP_ 14
   opLOADSP_ 15
   opLOADSP_ 16
   opLOADSP_ 17
   opLOADSP_ 18
   opLOADSP_ 19
   opLOADSP_ 20
   opLOADSP_ 21
   opLOADSP_ 22
   opLOADSP_ 23
   opLOADSP_ 24
   opLOADSP_ 25
   opLOADSP_ 26
   opLOADSP_ 27
   opLOADSP_ 28
   opLOADSP_ 29
   opLOADSP_ 30
   opLOADSP_ 31

opLOADSP_x
   LSLB              ; B ~ x*4
   EORB  #%01000000
   ANDB  #%01111100  ; clear bit 7 of 4*x
   LEAX  B,S         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHS  D,X         ; push 32 bits
   JMP   <fetch      ; next instruction

***************************************
* Write top of stack at stack[x]
* B=00xxxxx0 (2*x)
***************************************

opSTORESP_0
   LEAS  4,S
   NEXT

opSTORESP_1
   PULS  D,X
   STD   ,S
   STX   2,S
   NEXT

opSTORESP_ MACRO
opSTORESP_\0
   PULS  D,X
   STD   4*\0-4,S
   STX   4*\0-2,S
   NEXT
   ENDM

   opSTORESP_ 2
   opSTORESP_ 3
   opSTORESP_ 4
   opSTORESP_ 5
   opSTORESP_ 6
   opSTORESP_ 7
   opSTORESP_ 8
   opSTORESP_ 9
   opSTORESP_ 10
   opSTORESP_ 11
   opSTORESP_ 12
   opSTORESP_ 13
   opSTORESP_ 14
   opSTORESP_ 15
   opSTORESP_ 16
   opSTORESP_ 17
   opSTORESP_ 18
   opSTORESP_ 19
   opSTORESP_ 20
   opSTORESP_ 21
   opSTORESP_ 22
   opSTORESP_ 23
   opSTORESP_ 24
   opSTORESP_ 25
   opSTORESP_ 26
   opSTORESP_ 27
   opSTORESP_ 28
   opSTORESP_ 29
   opSTORESP_ 30
   opSTORESP_ 31

opSTORESP_x
   LSLB              ; B ~ x*4
   EORB  #%01000000
   LEAX  B,S         ; X point to dest (bit7 already 0)
   PULS  D           ; load low word
   STD   ,X          ; store low word
   PULS  D           ; load high word
   STD   2,X         ; store high word
   JMP   <fetch      ; next instruction

***************************************
* Adds to TOS the value at stack[x]
* B=0--xxxx00 (4*x)
***************************************


opADDSP_0
   LSL   3,S
   ROL   2,S
   ROL   1,S
   ROL   ,S
   NEXT

opADDSP_ MACRO
opADDSP_\0
  IFNE FUSE
* opADDSP_x opSTORESP_x --> almost no gain
   LDB   ,Y
   CMPB  #80+\0
   BNE   opADDSP_x\0
   LEAY  1,Y
  IFNE 0    ; 77980
   LDD   ,S++
   BEQ   opADDSP_c\0
   ADDD  4*\0-2,S
   STD   4*\0-2,S
opADDSP_c\0
   PULS  D
   ADDD  4*\0-2,S
   STD   4*\0-2,S
   BCC   opADDSP_d\0
   INC   4*\0-3,S
   BNE   opADDSP_d\0
   INC   4*\0-4,S
opADDSP_d\0
  ELSE      ; 77840
   LDD   4*\0+2,S
   ADDD  2,S
   STD   4*\0+2,S
   LDD   ,S
   LEAS  4,S
   ADCB  4*\0-4+1,S
   ADCA  4*\0-4,S
   STD   4*\0-4,S
  ENDC
   NEXT
opADDSP_x\0
  ENDC
  IFNE 1          ; 77860 --> fastest
   LDD   0+4*\0,S ; load high word of source
   BEQ   opADDSP_a\0
   ADDD  ,S
   STD   ,S
opADDSP_a\0
   LDD   2+4*\0,S ; load high word of source
   ADDD  2,S
   STD   2,S
   BCC   opADDSP_b\0
   INC   1,S
   BNE   opADDSP_b\0
   INC   ,S
opADDSP_b\0
  ELSE            ; 77920
   LDD   2+4*\0,S ; load low word of source
   ADDD  2,s      ; add low word of TOS
   STD   2,S      ; store result to TOS (lower word)
   LDD   0+4*\0,S ; load high word of source
   ADCB  1,S      ; add with carry the TOS (high word)
   ADCA  ,S       ; second byte
   STD   ,S       ; store result to TOS (high word)
  ENDC
   NEXT
   ENDM

   opADDSP_  1
   opADDSP_  2
   opADDSP_  3
   opADDSP_  4
   opADDSP_  5
   opADDSP_  6
   opADDSP_  7
   opADDSP_  8
   opADDSP_  9
   opADDSP_  11
   opADDSP_  12
   opADDSP_  13
   opADDSP_  10
   opADDSP_  14
   opADDSP_  15

opADDSP_x
   LSLB              ; B ~ 4*x
   ANDB  #%00111100  ; make 4*x postitive
   LEAX  B,S         ; X point to source
   LDD   2,S         ; load low word of source
   ADDD  2,X         ; add low word of TOS
   STD   2,X         ; store result to TOS (lower word)
   LDD   ,S          ; load high word of source
   ADCB  1,X         ; add with carry the TOS (high word)
   ADCA  ,X          ; second byte
   STD   ,S          ; store result to TOS (high word)
   NEXT

***************************************

opUNKNOWN

opBREAKPT
   LDA   STATUS
   ANDA  #%11011111  ; disable timer interrupt
   STA   STATUS
   SWI               ; back to monitor

* Pushes stack address
opPUSHSP
   LDD   #STK_SPACE  ; stack address is $01FF:9xxx
   LEAX  ,S
   PSHS  D,X
   NEXT

opPUSHSPADD
  IFNE FUSE
* opPUSHSPADD opPOPSP  408s --> 404s (-0.99%)
   LDB   ,Y+
   CMPB  #13
   BNE   opPUSHSPADDx
   LDD   2,S
   LSLD
   LSLD
   LEAS  D,S
   NEXT
opPUSHSPADDx
   LEAY  -1,Y
  ENDC

   LDD   #STK_SPACE  ; stack address is $07FF:9xxx
   STD   ,S          ; BANk 0, $Dxxx
   LDD   2,S
   LSLD
   LSLD
   LEAX  D,S
   STX   2,S
   NEXT


***************************************
* LOGIC
***************************************

BITWISE MACRO
   PULS  D,X
   \0A  ,S
   \0B  1,S
   STD   ,S
   TFR   X,D
   \0A  2,S
   \0B  3,S
   STD   2,S
   NEXT
  ENDM

opAND
  IFEQ 1
   BITWISE AND       ; [44] bitwise "and" of TOS with NOS
  ELSE
   LDD   ,S++
   BEQ   opAND1
   ANDA  2,S
   ANDB  3,S
opAND1
   STD   2,S
   PULS  D
   ANDA  2,S
   ANDB  3,S
   STD   2,S
   NEXT
  ENDC

opOR
  IFEQ 1
   BITWISE OR        ; bitwise "or" of TOS with NOS
  ELSE
   LDD   ,S++
   BEQ   opOR1
   ORA   2,S
   ORB   3,S
   STD   2,S
opOR1
   PULS  D
   ORA   2,S
   ORB   3,S
   STD   2,S
   JMP   <fetch
  ENDC

opXOR
   BITWISE EOR       ; bitwise "xor" of TOS with NOS

opNOT
  IFNE FUSE
* opNOT opIM_1 opAND   411s -> 408s (-0.7%)
   LDD   ,Y
   SUBD  #$8106
   BNE   opNOTx
   LEAY  2,Y
   LDD   #1
   ANDB  3,S
   EORB  #1
   STD   2,S
   CLRB
   STD   ,S
   NEXT
opNOTx
  ENDC
   COM   ,S          ; bitwise complement of TOS
   COM   1,S
   COM   2,S
   COM   3,S         ; 7*3+6=27
   NEXT

flip2
   LSRA              ; helper to flip A and B bits
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   RTS

opFLIP
   LDA   ,S          ; flips the bits of the TOS
   LDB   3,S
   BSR   flip2       ; 0/3
   STA   ,S
   STB   3,S
   LDD   1,S
   BSR   flip2       ; 1/2
   STD   1,S
   JMP   <fetch

opSWAP
   LDD   ,S
   LDX   2,S
   STX   ,S
   STD   2,S
   JMP   <fetch

***************************************
* MEMORY
***************************************

* https://github.com/zylin/zpu/blob/master/zpu/sw/startup/crt_io.c

* _cpu_config==0 => Abel
* _cpu_config==1 => Zeta
* _cpu_config==2 => Phi

* CONFIG=2 (phi board)
* UART  = 0x080a000c
* TIMER = 0x080a0014
* MHZ   = address to 64L

* Abel board
* UART  = 0xc000
* TIMER = 0x9000
* MHZ   = 0x8800

* Software board
* UART  = 0x80000024
* TIMER = 0x80000100
* MHZ   = 0x80000200

* TIMER[0] = 2 == latch
* TIMER[0] = low  long
* TIMER[1] = high long


 * UART[0] & 0x100 == 0 si busy (carractere a lire ?)
 * UART[0] = C ecriture
 * UART[1] = carractere lue | 0x100

  IFEQ  CYCLE_TIMER
timer_latch_phi
* phi expects running at 64Mhz, so multiply our microsecond timer by 64
   LDB   3,S
   CMPB  #$14        ; phi ?
   BNE   timer_latch_phi3
   LDB   #6
timer_latch_phi2
   LSL   sampledTMR+7
   ROL   sampledTMR+6
   ROL   sampledTMR+5
   ROL   sampledTMR+4
   ROL   sampledTMR+3
   ROL   sampledTMR+2
   ROL   sampledTMR+1
   ROL   sampledTMR
   DECB
   BNE   timer_latch_phi2
timer_latch_phi3
   JMP   opSTOREIO_end
  ENDC

timer_high
   LDX   sampledTMR     ; load high word of latched timer
   LDD   sampledTMR+2
   BRA   opLOADIO_end
timer_low
   LDX   sampledTMR+4   ; load low word of latched timer
   LDD   sampledTMR+6
   BRA   opLOADIO_end
timer_mhz
   LDX   #0             ; return Mhz (1 for Thomson rtc)
   IFNE  CYCLE_TIMER
   LDD   #64
   ELSE
   LDD   #1
   ENDC
   BRA   opLOADIO_end

uart_read
   LDA   #1          ; read keyoard
   JSR   GETC
   TSTB
   BNE   opLOADIO_end
   CLRA
   BRA   opLOADIO_end
uart_write
   LDB   7,S         ; prints a character
   JSR   PUTC
  IFNE  LPR
   IFEQ  TRACE
   JSR   RSCO
   ENDC
  ENDC
   BRA   opSTOREIO_end

timer_latch
   LDB   7,S
   BITB  #2
   BEQ   opSTOREIO_end
   PSHS  U,CC        ; latches the current timer value
   ORCC  #$50
   LDU   #TIMER_CTR
   PULU  D,X
   STD   sampledTMR
   STX   sampledTMR+2
   PULU  D,X
   STD   sampledTMR+4
   STX   sampledTMR+6
   PULS  U,CC
  IFEQ  CYCLE_TIMER
   BRA   timer_latch_phi
  ELSE
   BRA   opSTOREIO_end
  ENDC

opLOADIO
   LDX   #0
   LDD   2,S
* phi board
   CMPD  #$000C
   BEQ   uart_rdy
   CMPD  #$0010
   BEQ   uart_read
   CMPD  #$0014
   BEQ   timer_low
   CMPD  #$0018
   BEQ   timer_high
* soft board
   CMPD  #$0024
   BEQ   uart_rdy
   CMPD  #$0028
   BEQ   uart_read
   CMPD  #$0100
   BEQ   timer_low
   CMPD  #$0104
   BEQ   timer_high
   CMPD  #$0200
   BEQ   timer_mhz
* default
uart_rdy
   LDD   #256        ; tell uart is rady to send
opLOADIO_end
   STX   ,S
   STD   2,S
   JMP   <fetch

opSTOREIO
   LDD   2,S
* phi board
   CMPD  #$000C
   BEQ   uart_write
   CMPD  #$0014
   BEQ   timer_latch
* soft board
   CMPD  #$0024
   BEQ   uart_write
   CMPD  #$0100
   BEQ   timer_latch
opSTOREIO_end
   LEAS  8,S         ; fixup stack
   JMP   <fetch

* opLOAD IM_-1 EQ

opLOAD SET *
   LDA   ,S
   CMPA  #STK_SPACE/256
   BMI   opLOADnorm
   BHI   opLOADIO    ; yes => io-specific
   LDX   2,S
   BRA   opLOAD2
opLOADnorm SET *
   JSR   <getAddrMapped   ; convert adress
opLOAD2
   LDD   ,X          ; load high word
   STD   ,S          ; store in TOS
   LDD   2,X         ; load lower word
   STD   2,S         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction

opSTORE
   LDA   ,S
   CMPA  #STK_SPACE/256
   BMI   opSTOREnorm
   BHI   opSTOREIO    ; yes => io-specific
   LDX   2,S
   BRA   opSTORE2
opSTOREnorm SET *
   JSR   <getAddrMapped   ; convert adress
opSTORE2
   LDD   4,S
   STD   ,X
   LDD   6,S
   STD   2,X
   LEAS  8,S         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back

opPOPSP
   LDS   2,S
   NEXT

opLOADH
   JSR   <getAddr    ; loads 16 bits
   LDD   ,X
   BRA   outUnsigned

opSTOREH
   JSR   <getAddr    ; stores 16 bits
   LDD   6,S
   STD   ,X
   LEAS  8,S         ; fixup stack
   JMP   <updatePC

opLOADB
   JSR   <getAddr    ; loads 8 bits
   CLRA
   LDB   ,X
outUnsigned
   STD   2,S
   LDD   #0
   STD   ,S
   JMP   <updatePC

opSTOREB
   JSR   <getAddr    ; stores 8 bits
   LDB   7,S
   STB   ,X
   LEAS  8,S         ; fixup stack
   JMP   <updatePC

***************************************
* COMPARISON
***************************************

opLESSTHAN
   PULS  D,X
   SUBD  ,S
   BLT   outTRUE
   BGT   outFALSE
   CMPX  2,S
   BLO   outTRUE_D0
   BRA   outFALSE_D0

opLESSTHANOREQUAL
   PULS  D,X
   SUBD  ,S
   BLT   outTRUE
   BGT   outFALSE
   CMPX  2,S
   BLS   outTRUE_D0
   BRA   outFALSE_D0

opULESSTHAN
   PULS  D,X
   SUBD  ,S
   BLO   outTRUE
   BHI   outFALSE
   CMPX  2,S
   BLO   outTRUE_D0
   BRA   outFALSE_D0

opULESSTHANOREQUAL
   PULS  D,X
   SUBD  ,S
   BHI   outFALSE
   BLO   outTRUE
   CMPX  2,S
   BHI   outFALSE_D0
   BRA   outTRUE_D0

* opEQ opNOT --> opNEQ

opEQ
   PULS  D,X
   CMPX  2,S
   BNE   outFALSE
   SUBD  ,S
   BEQ   outTRUE_D0
outFALSE
   LDD   #0          ; writes 0 on top of stack
outFALSE_D0
   STD   ,S
   STD   2,S
   NEXT

opNEQ
   PULS  D,X
   CMPX  2,S
   BNE   outTRUE
   SUBD  ,S
   BNE   outTRUE
   
   BEQ   outFALSE_D0
outTRUE
   LDD   #0          ; write 1 on top of stack
outTRUE_D0
   STD   ,S
   INCB
   STD   2,S
   NEXT

***************************************
* SHIFT
***************************************

LSHIFTRIGHT MACRO
   LSRD
   ROR   2,X
   ROR   3,X
   ENDM

opLSHIFTRIGHT
   LEAX  4,S
   LDD   ,X
   BEQ   opLSHIFTRIGHT_half
   
   LSR   3,S
   BCC   opLSHIFTRIGHT2
   LSHIFTRIGHT
   
opLSHIFTRIGHT2
   LSR   3,S
   BCC   opLSHIFTRIGHT4
   LSHIFTRIGHT
   LSHIFTRIGHT
   
opLSHIFTRIGHT4
   LSR   3,S
   BCC   opLSHIFTRIGHT8
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   
opLSHIFTRIGHT8
   STD   ,X
   LSR   3,S
   BCC   opLSHIFTRIGHT16
*   abcd --> 0abc  swapped  cdab --> bc0a
   LDD   1,X
   STD   2,X
   CLRA
   LDB   ,X
   STD   ,X

opLSHIFTRIGHT16
   LSR   3,S
   BCC   opLSHIFTRIGHT32
*  abcd --> 00ab  swapped cdab --> ab00
   LDD   ,X
   STD   2,X
   LDD   #0
   STD   ,X
   
opLSHIFTRIGHT32
   LEAS  ,X
   JMP   <fetch

opLSHIFTRIGHT_half
   LDD   2,X
   LSR   3,S
   BCC   opLSHIFTRIGHT_half2
   LSRD
   
opLSHIFTRIGHT_half2
   LSR   3,S
   BCC   opLSHIFTRIGHT_half4
   LSRD
   LSRD
   
opLSHIFTRIGHT_half4
   LSR   3,S
   BCC   opLSHIFTRIGHT_half8
   LSRD
   LSRD
   LSRD
   LSRD
   
opLSHIFTRIGHT_half8
   LSR   3,S
   BCC   opLSHIFTRIGHT_half16
   TFR   A,B
   CLRA
   
opLSHIFTRIGHT_half16
   LSR   3,S
   BCC   opLSHIFTRIGHT_half32
   LDD   #0
   
opLSHIFTRIGHT_half32
   STD   2,X
   LEAS  ,X
   JMP   <fetch

ASHIFTLEFT MACRO
   LSLD
   ROL   1,X
   ROL   ,X
   ENDM

opASHIFTLEFT
   LEAX  4,S
   LDD   2,X
   BEQ   opASHIFTLEFT_half
   
   LSR   3,S
   BCC   opASHIFTLEFT2
   ASHIFTLEFT
   
opASHIFTLEFT2
   LSR   3,S
   BCC   opASHIFTLEFT4
   ASHIFTLEFT
   ASHIFTLEFT
   
opASHIFTLEFT4
   LSR   3,S
   BCC   opASHIFTLEFT8
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   
opASHIFTLEFT8
   STD   2,X
   LSR   3,S
   BCC   opASHIFTLEFT16
* abcd --> bcd0 swapped cdab --> d0bc
   LDD   1,X
   STD   ,X
   LDA   3,X
   CLRB
   STD   2,X

opASHIFTLEFT16
   LSR   3,S
   BCC   opASHIFTLEFT32
* abcd --> cd00 swapped cdab --> 00cd
   LDD   2,X
   STD   ,X
   LDD   #0
   STD   2,X
   
opASHIFTLEFT32
   LEAS  ,X
   JMP   <fetch

opASHIFTLEFT_half
   LDD   ,X
   BCC   opASHIFTLEFT_half2
   LSR   3,S
   LSLD
   
opASHIFTLEFT_half2
   LSR   3,S
   BCC   opASHIFTLEFT_half4
   LSLD
   LSLD
   
opASHIFTLEFT_half4
   LSR   3,S
   BCC   opASHIFTLEFT_half8
   LSLD
   LSLD
   LSLD
   LSLD
   
opASHIFTLEFT_half8
   LSR   3,S
   BCC   opASHIFTLEFT_half16
   TFR   B,A
   CLRB
   
opASHIFTLEFT_half16
   LSR   3,S
   BCC   opASHIFTLEFT_half32
   LDD   #0
   
opASHIFTLEFT_half32
   STD   ,X
   LEAS  ,X
   JMP   <fetch

ASHIFTRIGHT MACRO
   ASRD
   ROR   2,X
   ROR   3,X
   ENDM

opASHIFTRIGHT
   LEAX  4,S
   LDD  ,X
   LSR  3,S
   BCC   opASHIFTRIGHT2
   ASHIFTRIGHT
   
opASHIFTRIGHT2
   LSR   3,S
   BCC   opASHIFTRIGHT4
   ASHIFTRIGHT
   ASHIFTRIGHT
   
opASHIFTRIGHT4
   LSR   3,S
   BCC   opASHIFTRIGHT8
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   
opASHIFTRIGHT8
   STD   ,X
   LSR   3,S
   BCC   opASHIFTRIGHT16
* abcd --> xabc  swapped cdab --> bcxa
   LDD   1,X
   STD   2,X
   LDB   ,X
   SEX
   STD   ,X
  
opASHIFTRIGHT16
   LSR   3,S
   LEAS  ,X
   BCC   opASHIFTRIGHT32
* abcd --> xxab swapped cdab --> abxx
   LDX   #0
   LDD   ,S
   STD   2,S
   BPL   opASHIFTRIGHT16x
   LDX   #-1
opASHIFTRIGHT16x
   STX   ,S
opASHIFTRIGHT32
   JMP   <fetch

***************************************
* CONTROL FLOW (PC RELATED)
***************************************

opNEQBRANCH
   LDD   6,S
   BNE   doBRANCH
   LDD   4,S
   BNE   doBRANCH
noBRANCH
   LEAS  8,S
   NEXT

opEQBRANCH
   LDD   4,S
   BNE   noBRANCH
   LDD   6,S
   BNE   noBRANCH
   * BRA   BRANCH
   
DO_BRANCH MACRO
  IFNE SMALL_BRNCH
   LDD   2,S
   BPL   DO_Bp\1
   CMPA  #-1
   BEQ   DO_Bm\1
DO_B2\1   
  ENDC
   TFR   Y,D
   SUBD  #$A001
   ADDA  <PC_PG+1
   ADDD  2,S
   STA   <PC_PG+1
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ROLA              ; save carry in b0
   ADDA  #%01000000
   LSRA              ; get cary back
   ORA   #%10000000
   TFR   D,Y         ; update pc reg
   LDD   <PC_PG
   ADCA  1,S
   ANDB  #$C0        ; align 16k
   STD   <PC_PG      ; update high word of PC
   LEAS  \0,S         ; fixup stack
   JMP   <updatePC_D ; update page etc
  IFNE SMALL_BRNCH
DO_Bp\1
   CMPA  1,S
   BNE   DO_B2\1 
   LEAX  ,Y
   ABX
   CMPX  #$E001
   BCC   DO_B2\1
   LEAY  -1,X
   LEAS  \0,S
   NEXT
DO_Bm\1
   CMPA  1,S
   BNE   DO_B2\1 
   LEAX  D,Y
   CMPX  #$A001
   BCS   DO_B2\1
   LEAY  -1,X
   LEAS  \0,S
   NEXT
  ENDC
   ENDM

doBRANCH
  IFEQ 0
   DO_BRANCH 8,doBRANCH
  ELSE
   PULS  D,X
   STD   ,S
   STX   2,S
   BRA   opPOPPCREL
  ENDC

opEMULATE_x
   LSLB              ; B=1xxx xx00
   LSLB              ; B=xxxx x000
   BEQ   opASHIFTRIGHT32 ; fetch
   CLRA              ; D=0000 0000 xxxx x000
   LSLD              ; D=0000 000x xxxx 0000
   LSLD              ; D=0000 00xx xxx0 0000=x*32
   TFR   D,X
   LDD   #0
   PSHS  D,X
   BRA   opCALL
   
opCALLPCREL
   TFR   Y,D
   SUBD  #$A001
   ADDA  <PC_PG+1
   ADDD  2,S
   STD   2,S
   LDB   1,S
   ADCB  <PC_PG
   CLRA              ; 24 bits
   STD   ,S
   * BRA   opCALL

opCALL
   LDD   1,S
   ANDB  #$C0        ; clear lower bit

  IFNE 1
   CMPD  <PC_PG
   BNE   opCALL2
   LDD   2,S         ; fix lower bits
   ANDA  #$3F
   ADDA  #$A0
   EXG   Y,D         ; update PC_REG
   SUBA  #$A0        ; clear upper bits of old PC
   ADDA  <PC_PG+1    ; add page lower bits
   STD   2,S         ; store lower word of PC
   NEXT
opCALL2
  ENDC
  
   TFR   D,X         ; saves PC_PG

   LDD   2,S         ; fix lower bits
   ANDA  #$3F
   ADDA  #$A0
   EXG   Y,D         ; update PC_REG

   SUBA  #$A0        ; clear upper bits of old PC
   ADDA  <PC_PG+1    ; add page lower bits
   STD   2,S         ; store lower word of PC
   LDB   <PC_PG      ; load pages upper bits
   STB   1,S
*   CLRA              ; PC is 24 bits
*   STD   ,S          ; store upper word of PC

   STX   <PC_PG      ; update PC page
   JMP   <updatePC

opPOPPCREL
   DO_BRANCH 4,opPOPPCREL

opPOPPC
   LDD   2,S         ; lower word of PC
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ADDA  #$A0
   TFR   D,Y         ; update pc reg
   LDD   1,S         ; load page field
   ANDB  #$C0        ; align 16k
  IFNE 1
   CMPD  <PC_PG
   BNE   opPOPPC2
   LEAS  4,S         ; fixup stack
   NEXT
opPOPPC2
  ENDC
   STD   <PC_PG      ; update high word of PC
   LEAS  4,S         ; fixup stack
   JMP   <updatePC_D ; update page etc

opPUSHPC
   CLRA               ; 24 bits
   LDB   <PC_PG
   TFR   D,X

   TFR   Y,D
   SUBA  #$A0
   ADDA  <PC_PG+1
   SUBD  #1
   BCC   opPUSHPC2
   LEAX  -1,X
opPUSHPC2
   PSHS  D,X
   JMP   <fetch

***************************************
* INSTRUCTION TABLE
***************************************
   FDB   opSTORESP_16         ; 64 %0100 0000
   FDB   opSTORESP_17         ; 65 %0100 0001
   FDB   opSTORESP_18         ; 66 %0100 0010
   FDB   opSTORESP_19         ; 67 %0100 0011
   FDB   opSTORESP_20         ; 68 %0100 0100
   FDB   opSTORESP_21         ; 69 %0100 0101
   FDB   opSTORESP_22         ; 70 %0100 0110
   FDB   opSTORESP_23         ; 71 %0100 0111
   FDB   opSTORESP_24         ; 72 %0100 1000
   FDB   opSTORESP_25         ; 73 %0100 1001
   FDB   opSTORESP_26         ; 74 %0100 1010
   FDB   opSTORESP_27         ; 75 %0100 1011
   FDB   opSTORESP_28         ; 76 %0100 1100
   FDB   opSTORESP_29         ; 77 %0100 1101
   FDB   opSTORESP_30         ; 78 %0100 1110
   FDB   opSTORESP_31         ; 79 %0100 1111
   FDB   opSTORESP_0          ; 80 %0101 0000
   FDB   opSTORESP_1          ; 81 %0101 0001
   FDB   opSTORESP_2          ; 82 %0101 0010
   FDB   opSTORESP_3          ; 83 %0101 0011
   FDB   opSTORESP_4          ; 84 %0101 0100
   FDB   opSTORESP_5          ; 85 %0101 0101
   FDB   opSTORESP_6          ; 86 %0101 0110
   FDB   opSTORESP_7          ; 87 %0101 0111
   FDB   opSTORESP_8          ; 88 %0101 1000
   FDB   opSTORESP_9          ; 89 %0101 1001
   FDB   opSTORESP_10         ; 90 %0101 1010
   FDB   opSTORESP_11         ; 91 %0101 1011
   FDB   opSTORESP_12         ; 92 %0101 1100
   FDB   opSTORESP_13         ; 93 %0101 1101
   FDB   opSTORESP_14         ; 94 %0101 1110
   FDB   opSTORESP_15         ; 95 %0101 1111

   FDB   opLOADSP_16          ; 96 %0110 0000
   FDB   opLOADSP_17          ; 97 %0110 0001
   FDB   opLOADSP_18          ; 98 %0110 0010
   FDB   opLOADSP_19          ; 99 %0110 0011
   FDB   opLOADSP_20          ;100 %0110 0100
   FDB   opLOADSP_21          ;101 %0110 0101
   FDB   opLOADSP_22          ;102 %0110 0110
   FDB   opLOADSP_23          ;103 %0110 0111
   FDB   opLOADSP_24          ;104 %0110 1000
   FDB   opLOADSP_25          ;105 %0110 1001
   FDB   opLOADSP_26          ;106 %0110 1010
   FDB   opLOADSP_27          ;107 %0110 1011
   FDB   opLOADSP_28          ;108 %0110 1100
   FDB   opLOADSP_29          ;109 %0110 1101
   FDB   opLOADSP_30          ;110 %0110 1110
   FDB   opLOADSP_31          ;111 %0110 1111
   FDB   opLOADSP_0           ;112 %0111 0000
   FDB   opLOADSP_1           ;113 %0111 0001
   FDB   opLOADSP_2           ;114 %0111 0010
   FDB   opLOADSP_3           ;115 %0111 0011
   FDB   opLOADSP_4           ;116 %0111 0100
   FDB   opLOADSP_5           ;117 %0111 0101
   FDB   opLOADSP_6           ;118 %0111 0110
   FDB   opLOADSP_7           ;119 %0111 0111
   FDB   opLOADSP_8           ;120 %0111 1000
   FDB   opLOADSP_9           ;121 %0111 1001
   FDB   opLOADSP_10          ;122 %0111 1010
   FDB   opLOADSP_11          ;123 %0111 1011
   FDB   opLOADSP_12          ;124 %0111 1100
   FDB   opLOADSP_13          ;125 %0111 1101
   FDB   opLOADSP_14          ;126 %0111 1110
   FDB   opLOADSP_15          ;127 %0111 1111

opTable
   FDB   opBREAKPT            ;  0 %0000 0000
   FDB   opUNKNOWN            ;  1 %0000 0001
   FDB   opPUSHSP             ;  2 %0000 0010
   FDB   opUNKNOWN            ;  3 %0000 0011
   FDB   opPOPPC              ;  4 %0000 0100
   FDB   opADD                ;  5 %0000 0101
   FDB   opAND                ;  6 %0000 0110
   FDB   opOR                 ;  7 %0000 0111
   FDB   opLOAD               ;  8 %0000 1000
   FDB   opNOT                ;  9 %0000 1001
   FDB   opFLIP               ; 10 %0000 1010
   FDB   opNOP                ; 11 %0000 1011
   FDB   opSTORE              ; 12 %0000 1100
   FDB   opPOPSP              ; 13 %0000 1101
   FDB   opUNKNOWN            ; 14 %0000 1110
   FDB   opUNKNOWN            ; 15 %0000 1111

   FDB   opADDSP_0            ; 16 %0001 0000
   FDB   opADDSP_1            ; 17 %0001 0001
   FDB   opADDSP_2            ; 18 %0001 0010
   FDB   opADDSP_3            ; 19 %0001 0011
   FDB   opADDSP_4            ; 20 %0001 0100
   FDB   opADDSP_5            ; 21 %0001 0101
   FDB   opADDSP_6            ; 22 %0001 0110
   FDB   opADDSP_7            ; 23 %0001 0111
   FDB   opADDSP_8            ; 24 %0001 1000
   FDB   opADDSP_9            ; 25 %0001 1001
   FDB   opADDSP_10           ; 26 %0001 1010
   FDB   opADDSP_11           ; 27 %0001 1011
   FDB   opADDSP_12           ; 28 %0001 1100
   FDB   opADDSP_13           ; 29 %0001 1101
   FDB   opADDSP_14           ; 30 %0001 1110
   FDB   opADDSP_15           ; 31 %0001 1111

   FDB   opEMULATE_x          ; 32 %0010 0000
   FDB   opUNKNOWN            ; 33 %0010 0001
   FDB   opLOADH              ; 34 %0010 0010
   FDB   opSTOREH             ; 35 %0010 0011
   FDB   opLESSTHAN           ; 36 %0010 0100
   FDB   opLESSTHANOREQUAL    ; 37 %0010 0101
   FDB   opULESSTHAN          ; 38 %0010 0110
   FDB   opULESSTHANOREQUAL   ; 39 %0010 0111
   FDB   opSWAP               ; 40 %0010 1000
   FDB   opMULT               ; 41 %0010 1001
   FDB   opLSHIFTRIGHT        ; 42 %0010 1010
   FDB   opASHIFTLEFT         ; 43 %0010 1011
   FDB   opASHIFTRIGHT        ; 44 %0010 1100
   FDB   opCALL               ; 45 %0010 1101
   FDB   opEQ                 ; 46 %0010 1110
   FDB   opNEQ                ; 47 %0010 1111

   FDB   opNEG                ; 48 %0011 0000
   FDB   opSUB                ; 49 %0011 0001
   FDB   opXOR                ; 50 %0011 0010
   FDB   opLOADB              ; 52 %0011 0011
   FDB   opSTOREB             ; 52 %0011 0100
   FDB   opDIV                ; 53 %0011 0101
   FDB   opMOD                ; 54 %0011 0110
   FDB   opEQBRANCH           ; 55 %0011 0111
   FDB   opNEQBRANCH          ; 56 %0011 1000
   FDB   opPOPPCREL           ; 57 %0011 1001
   FDB   opEMULATE_x          ; 58 %0011 1010 opCONFIG
   FDB   opPUSHPC             ; 59 %0011 1011
   FDB   opEMULATE_x          ; 60 %0011 1100 opSYSCALL
   FDB   opPUSHSPADD          ; 61 %0011 1101
   FDB   opMULT16X16          ; 62 %0011 1110
   FDB   opCALLPCREL          ; 63 %0011 1111
(info)

***************************************
* MONITOR and TRACING
***************************************

OPCDE MACRO
   FCC   \0
   FCB   \1+0
   ENDM

   IFNE  TRACE
doTRACE
   PSHS  CC,DP,D,X,Y,U
   LEAX  12,S
   LDU   #traceFmt
doTRACE1
   LDB   ,U+
   BEQ   endTRACE
   CMPB  #'%
   BNE   doTRACE2
   BSR   doTRACE3
   BRA   doTRACE1
doTRACE2
   JSR   PUTCHAR
   BRA   doTRACE1
endTRACE
   PULS  CC,DP,D,X,Y,U,PC

doTRACE3
   LDB   ,U+            ; decodes %thing
   CMPB  #'s
   BEQ   printSTACK
   CMPB  #'p
   BEQ   printPC
   CMPB  #'o
   BEQ   printOP
   CMPB  #'a
   BEQ   printASM
   CMPB  #'u
   BEQ   printSP
   RTS

printSP
   PSHS  X              ; prints 16bit stack ptr
   LEAX  ,S
   JSR   HEX16
   PULS  X,PC

printOP
   LDB   ,y             ; prints 8bit op-code
   JMP   HEX

printPC
   PSHS  D,X            ; prints 24bit PC reg
   TFR   Y,D
   SUBA  #$A0
   ORA   <PC_PG+1
   PSHS  D
   CLRA
   LDB   <PC_PG
   PSHS  D
   LEAX  1,S
   JSR   HEX8
   JSR   HEX16
   LEAS  ,X
   PULS  D,X,PC

printSTACK
   CMPX  #$A000
   LBLO  HEX32
   JSR   PUTSTR
   COLOR 4
   IFNE  LPR
   FCC   /-------/
   FCB   128+'-
   ELSE
   FCC   /--------/
   ENDC
   COLOR 128+COLOR_STACK
   RTS

printASM
   PSHS  X,U
   LDU   #asmTbl           ; find the #B th entry in table
   LDB   ,Y
   BPL   srchMNEMO

   JSR   PUTSTR            ; IM d
   FCC   /IM/
   FCB   128+32
   LSLB
   ASRB
   BRA   noXOR

srchMNEMO
   LDA   #32
   INCB
srchLOOP
   CMPA  ,U
   BHI   skipMNEMO
   LEAX  ,U+
skipMNEMO
   CMPA  ,U+
   BLS   skipMNEMO
   DECB
   BNE   srchLOOP
   LDB   ,X+
printOPCDE
   JSR   PUTCHAR
   LDB   ,X+
   CMPB  #32
   BHS   printOPCDE
   TSTB
   BEQ   noDECIMAL
   ANDB  ,y
printDECIMAL
   LDA   #%01000000
   ANDA  ,y
   BEQ   noXOR
   EORB  #$10
noXOR
   JSR   DECIMAL
noDECIMAL
   PULS  X,U,PC

COLOR_ST    SET   2
COLOR_PC    SET   3
COLOR_OP    SET   6
COLOR_INST  SET   5
COLOR_STACK  SET  4


traceFmt
  IFEQ  LPR
* nice colorful trace
   * IFEQ  LPR
   * FCB   10,10,11,11
   * ENDC
   COLOR COLOR_STACK
   FCC   /%s %s %s %s/
   FCB   13,10
   COLOR COLOR_ST
   FCC   /%u /
   COLOR COLOR_PC
   FCC   /%p /
   COLOR COLOR_OP
   FCC   /%o /
   COLOR COLOR_INST
   FCC   /%a/
   COLOR COLOR_STACK
   FCB   13,10,0
  ELSE
* compatible with zpu.c
   FCC   /0x0%p 0x%o 0x%u/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   fcc   / %a/
   FCB   10,0
  ENDC

asmTbl
   OPCDE /BREAKPT/            ; 0
   OPCDE /???/                ; 1
   OPCDE /PUSHSP/             ; 2
   OPCDE /???/                ; 3
   OPCDE /POPPC/              ; 4
   OPCDE /ADD/                ; 5
   OPCDE /AND/                ; 6
   OPCDE /OR/                 ; 7
   OPCDE /LOAD/               ; 8
   OPCDE /NOT/                ; 9
   OPCDE /FLIP/               ; 10
   OPCDE /NOP/                ; 11
   OPCDE /STORE/              ; 12
   OPCDE /POPSP/              ; 13
   OPCDE /???/                ; 14
   OPCDE /???/                ; 15
   OPCDE /ADDSP/,32           ; 16..31
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   OPCDE /EMULATE/,32         ; 32
   FCB   31
   OPCDE /???/                ; 33
   OPCDE /LOADH/              ; 34
   OPCDE /STOREH/             ; 35
   OPCDE /LESSTHAN/           ; 36
   OPCDE /LESSTHANOREQUAL/    ; 37
   OPCDE /ULESSTHAN/          ; 38
   OPCDE /ULESSTHANOREQUAL/   ; 39
   OPCDE /SWAP/               ; 40
   OPCDE /MULT/               ; 41
   OPCDE /LSHIFTRIGHT/        ; 42
   OPCDE /ASHIFTLEFT/         ; 43
   OPCDE /ASHIFTRIGHT/        ; 44
   OPCDE /CALL/               ; 45
   OPCDE /EQ/                 ; 46
   OPCDE /NEQ/                ; 47
   OPCDE /NEG/                ; 48
   OPCDE /SUB/                ; 49
   OPCDE /XOR/                ; 50
   OPCDE /LOADB/              ; 51
   OPCDE /STOREB/             ; 52
   OPCDE /DIV/                ; 53
   OPCDE /MOD/                ; 54
   OPCDE /EQBRANCH/           ; 55
   OPCDE /NEQBRANCH/          ; 56
   OPCDE /POPPCREL/           ; 57
   OPCDE /CONFIG/             ; 58
   OPCDE /PUSHPC/             ; 59
   OPCDE /SYSCALL/            ; 60
   OPCDE /PUSHSPADD/          ; 61
   OPCDE /MULT16X16/          ; 62
   OPCDE /CALLPCREL/          ; 63
   OPCDE /STORESP/,32         ; 64..95
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   OPCDE /LOADSP/,32         ; 96..127
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31

(info)
   ENDC

FILENAME
   FCC   /0:/
   * FCC   /dhr13k  /
   FCC   /dhryston/
   * FCC   /test    /
   * FCC   /test2   /
   * FCC   /a       /
   * FCC   /eliza   /
   FCC   /bin/
   FCB   0

FAT
   RMB   256
BUF
   RMB   256

***************************************
* Hello world example
***************************************
   * ORG   $A000

* INCDAT dhryston.bin

   IFNE  0
* https://github.com/tobyjaffey/libzpu/blob/master/zpusim-mini/zpusim-mini.c
   FCB   $80,$3d,$0d,$f8,$80,$80,$82
   FCB   $80,$51,$80,$c8,$71,$0c,$80
   FCB   $e5,$71,$0c,$80,$ec,$71,$0c
   FCB   $80,$ec,$71,$0c,$80,$ef,$71
   FCB   $0c,$a0,$71,$0c,$80,$d7,$71
   FCB   $0c,$80,$ef,$71,$0c,$80,$f2
   FCB   $71,$0c,$80,$ec,$71,$0c,$80
   FCB   $e4,$71,$0c,$8d,$71,$0c,$8a
   FCB   $71,$0c,$00,$82,$3d,$0d,$04
   ENDC
HEAP

   END   main
