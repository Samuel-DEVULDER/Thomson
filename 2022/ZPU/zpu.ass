(main)zpu
   ORG   $6300

safe SET 0

   SETDP */256

* loads a continuated immediate value
* B=xxxxxxx0 (value*2)
opIM_nxt
   LSR   ,U          ; rotate TOS 7 bits left
   LDA   1,U
   RORA
   STA   ,U          ; byte 0 is byte 1 rotated right once
   LDA   2,U
   RORA
   STA   1,U         ; byte 1 is byte 2 rotated right once
   LDA   3,U
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   STD   2,U         ; write lower word
   LDB   [fetch+1]   ; is next opcode an opIm?
   BMI   incPC       ; yes => just increment PC
   LDA   #$81        ; no => disable hook ($81=CMPA)
   STA   <opIM       ; (write CMPA as the first instructon of opIM)
   BRA   incPC       ; next instruction (B already fetched)


* loads a 7 bit immediate value
* B=xxxxxxx0 (value*2)
opIM
   BRN   opIM_nxt    ; hook to go to continued version (dynamic code)
   ASRB              ; left align signed value
   SEX               ; extends sign to A ($00 or $FF)
   PSHU  D           ; push lower word
   STA   ,-U         ; push high byte (sign)
   STA   ,-U         ; push high byte (sign)
   LDB   [fetch+1]   ; is next opcode an immediate value?
   BPL   incPC       ; no => no change in hook. just update the PC reg.
   LDA   #$20        ; yes => mak hook go to opIM_nxt ($20=BRA)
   STA   <opIM       ; (write a BRA as the first instructio, of opIM)
   BRA   incPC       ; next instruction (B already fetched)

* safe version of getAddr for long values
getAddrL
   IF safe
   LDB   #%11111100
   ANDB  3,U         ; just clear the 2 lower bits of TOS
   STB   3,U
   ENDC

* make X points to the address in TOS (stack unmodified)
getAddr
   LDD   2,U         ; load lower part of the address
   ANDA  #$30        ; clear high bits
   ADDA  #$a0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X opdated
   LDD   1,U         ; load 16kb page section of address

* updates page when neeeded
* D=high bytes of the 24bits address
updatePage
   ANDB  #$c0        ; just keep the 2 top bits
   CMPD  #page       ; compare wit current page index
page equ *-2         ; page index (dynamic code)
   BEQ   donePage    ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA '
* map proper bank onto $A000...$DFFF space
* A=bank number
chgBank
   STA   $e7e6       ; need to check, might use PIA instead
donePage
   RTS               ; done

* restore the page back to the instruction page
updatePC
   LDD  #PC_HI       ; load instruction page
PC_HI SET *-2        ; instruction page (dynamic code)
   BSR  updatePage   ; update page if needed

* fetches and execute an instruction
fetch
   LDB   >$a000      ; load instruction byte
PC_LO equ *-2

* increments PC register
incPC
   INC   <PC_LO+1    ; update lower byte of the PC
   BNE   decode      ; no overflow => just decode instruction
   INC   <PC_LO      ; update upper part of the PC
   LDA   <PC_LO
   CMPA  #$E0        ; crossing $E000 ?
   BNE   decode      ; no => just decode the instruction
   LDA   #$A0        ; yes => next instruction page
   STA   <PC_LO      ; make PC point to $A000
   PSHS  B           ; saves current opcode
   LDD   <PC_HI      ; advance instruction page
   ADDD  #$40        ; by 16kb (a memory bank)
   STD   <PC_HI      ; update instruction page
   PULS  B
   BSR   updatePage  ; update bank

* deccdes the current opcode (in B)
decode
   LSLB              ; double the opcode
   BCS   opIM        ; opcode=1xxxxxxx ? yes => immediate value
   LSLB              ; ELSE make B = xxxxxx00
   BCS   opLDSTsp    ; opcode=01xxxxxx ? yes => LDsp_x or STsp_x
   BMI   opEMULATE_x ; opcode=001xxxxx ? yes => emulate_x
   BITB  #%01000000  ; opcode=0001xxxx ? yes => addsp_x
   BNE   opADDSP_x   ; at this point opcode=0000xxxx
   ldx   #basicOPs
   LSRB
   JMP   [B,X]

opEMULATE_x
   SUBB  #%10100010
   LSRB
   LDX   #extendedOPs
   JMP   [B,X]

* COMmon part between opLD and opST depending on N flag
opLDSTsp
   BPL   opSTORESP_x

***************************************
* Load on stack the value at stack[x]
* B=-xxxxx00 (4*x)
***************************************
opLOADSP_x
   ANDB  %01111100   ; clear bit 7 of 4*x
   LEAX  B,U         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHU  D,X         ; push 32 bits
   BRA   fetch       ; next instruction

* Write top of stack at stack[x]
* B=0xxxxx00 (4*x)
opSTORESP_x
   LEAX  B,U         ; X point to dest (bit7 already 0)
   LDD   ,U          ; load high word
   STD   ,X          ; store high word
   LDD   2,U         ; load low word
   STD   2,X         ; store low word
   LEAU  4,U         ; adjust the stack
   BRA   fetch       ; next instructio,

* Adds to TOS the value at stack[x]
* B=0--xxxx00 (4*x)
opADDSP_x
   ANDB  %00111100   ; make 4*x postitive
   LEAX  B,U         ; X point to source
   LDD   2,X         ; load low word of source
   ADDD  2,U         ; add low word of TOS
   STD   2,U         ; store result to TOS (lower word)
   LDD   ,X          ; load high word of source
   ADCB  1,U         ; add with carry the TOS (high word)
   ADCA  ,U          ; second byte
   STD   ,U          ; store result to TOS (high word)
   BRA   fetch       ; next instruction

opUNK
   BRA   opUNK

opBREAKPT
   BRA   opBREAKPT   ; do nothing (breakpoint)

opNOP
   JMP   <fetch      ; do nothing

* Pushes stack address
opPUSHSP
   LDD   #0          ; stack address is $0000:9xxx
   LEAX  ,U          ; this should be mapped to
   PSHU  D,X         ; bank 0, $Dxxx
   JMP   <fetch

opPOPPC
   LDD   2,U         ; lower word of PC
   ANDA  #$03        ; map 16k address to $A000...$DFFF
   ADDA  #$A0
   STD   <fetch+1    ; update pc reg
   LDD   1,U         ; load page field
   STD   <PC_HI      ; upodate high word of PC
   LEAU  4,U         ; fixup stack
   JMP   <updatePC+3 ; update page etc

***************************************
* ARITHMETIC
***************************************

opADD
   LEAU  4,U         ; add TOS with NOS
   LDD   2,U         ; load lower word of NOS
   ADDD  -2,U        ; adds lower word of TOS
   STD   2,U         ; store result to NOS lower part
   LDD   ,U          ; load NOS top word
   ADCB  -3,U        ; adds TOS top word
   ADCA  -4,U        ; with carry
   STD   ,U          ; store uppdr world result
   JMP   <fetch      ; next intruction

opSUB
   LEAU  4,U         ; add TOS with NOS
   LDD   2,U         ; load lower word of NOS
   SUBD  -2,U        ; adds lower word of TOS
   STD   2,U         ; store result to NOS lower part
   LDD   ,U          ; load NOS top word
   SBCB  -3,U        ; adds TOS top word
   SBCA  -4,U        ; with carry
   STD   ,U          ; store uppdr world result
   JMP   <fetch      ; next intruction

opNEG
   LDD   #0
   SUBD  2,U
   STD   2,U
   LDD   #0
   BCC   opNEG2
   LDD   #-1
opNEG2
   SUBD  ,U
   STD   ,U
   JMP   <fetch

opMULT
   LDD   #0          ; clear upper word
   STD   -4,U        ; 0123
   LDA   3,U         ; 4567
   LDB   7,U
   MUL               ; compute byte #4
   STD   -2,U        ; 3*7
   LEAX  -3,U
   LDD   #$0108      ; compute byte #3
   BSR   MULT1       ; 2*7
   BSR   MULT1       ; 3*6
   LEAX  -4,U
   LDD   #$0208      ; compute byte #2
   BSR   MULT2       ; 1*7
   BSR   MULT2       ; 2*6
   BSR   MULT2       ; 3*5
   LDD   #$0308      ; compute byte #1
   BSR   MULT3       ; 0*7
   BSR   MULT3       ; 1*6
   BSR   MULT3       ; 2*5
   BSR   MULT3       ; 3*4
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   ,U
   LDD   2,X
   STD   2,U
   JMP   <fetch
MULT1
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   BNE   MULT0
   INC   -1,X
MULT0
   PULS  D,PC
MULT2
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   PULS  D,PC
MULT3
   ADDD  #255        ; A++ B--
   PSHS  D
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDB  ,X
   STB   ,X
   PULS  D,PC

***************************************
* LOGIC
***************************************

opAND
   LDD   ,U          ; bitwise "and" of TOS with NOS
   LEAU  4,U
   ANDA  ,U
   ANDB  2,U
   STD   ,U
   LDD   -2,U
   ANDA  2,U
   ANDB  3,U
   STD   2,U
   JMP   <fetch

opOR
   LDD   ,U          ; bitwise "or" of TOS with NOS
   LEAU  4,U
   ORA   ,U
   ORB   2,U
   STD   ,U
   LDD   -2,U
   ORA   2,U
   ORB   3,U
   STD   2,U
   JMP   <fetch

opXOR
   LDD   ,U          ; bitwise "or" of TOS with NOS
   LEAU  4,U
   EORA  ,U
   EORB  2,U
   STD   ,U
   LDD   -2,U
   EORA  2,U
   EORB  3,U
   STD   2,U
   JMP   <fetch

opNOT
   COM   ,U          ; bitwise complement of TOS
   COM   1,U
   COM   2,U
   COM   3,U
   JMP   <fetch

flip2
   LSLA              ; helper to flip A and B bits
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ADCA  #0
   RTS

opFLIP
   LDA   ,U          ; flips the bits of tje TOS
   LDB   3,U
   BSR   flip2
   STA   ,U
   STB   3,U
   LDD   1,U
   BSR   flip2
   STD   1,U
   JMP   <fetch

opSWAP
   LDD   ,U
   LDX   2,U
   STX   ,U
   STD   2,U
   JMP   <fetch

***************************************
* MEMORY
***************************************

opLOADIO
   LDD   2,U
   CMPD  #12         ; UART
   BEQ   opLOADUART
   CMPD  #24         ; UART
   BEQ   opLOADUART
opLOADIO_end
   CLRA
   STD   2,U
   STA   1,U
   STA   ,U
   JMP   <fetch
opLOADUART
   JSR   $E806
   BRA   opLOADIO_end

opSTOREIO
   LDD   2,U
   CMPD  #12         ; UART
   BEQ   opSTOREUART
   CMPD  #24         ; UART
   BEQ   opSTOREUART
opSTOREIO_end
   LEAU  8,U
   JMP   <fetch
opSTOREUART
   LDB   7,U
   JSR   $E803
   BRA   opSTOREIO_end

opLOAD
   LDB   ,U
   BMI   opLOADIO
   JSR   <getAddrL   ; convert adress
   LDD   ,X          ; load high word
   STD   ,U          ; store in TOS
   LDD   2,X         ; load lower word
   STD   2,U         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction

opSTORE
   LDB   ,U
   BMI   opSTOREIO
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   4,U
   STD   ,X
   LDD   6,U
   STD   2,X
   LEAU  8,U
   JMP   <updatePC   ; page has been modified, ensure PC-page is back

opPOPSP
   PULU  D,X         ; change SP with the value of TOS
   LEAU  ,X          ; presumably we just keep the lower part of the address
   JMP   <fetch

opLOADH
   JSR   <getAddr    ; loads 16 bits
   LEAU  4,U
   LDX   ,X
   BMI   opLoadH2
   LDD   #0
opLoadH1
   PSHU  D,X
   JMP   <updatePC
opLoadH2
   LDD   #-1
   PSHU  D,X
   JMP   <updatePC

opSTOREH
   JSR   <getAddr    ; stores 16 bitx
   LEAU  8,U
   LDD   -2,U
   STD   ,X
   JMP   <updatePC

opLOADB
   JSR   <getAddr    ; loads 16 bits
   LEAU  4,U
   LDB   ,X
   SEX
   LDX   #0
   LEAX  A,X
   PSHU  D,X
   JMP   <updatePC

opSTOREB
   JSR   <getAddr    ; stores 16 bitx
   LEAU  8,U
   LDB   -1,U
   STB   ,X
   JMP   <updatePC

***************************************
* COMPARISON
***************************************

opLESSTHAN
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BLT   outTRUE
   BGT   outFALSE
   LDD   -2,U
   SUBD  2,U
   BMI   outTRUE
outFALSE
   LDD   #0          ; writes 0 on top of stack
   STD   ,U
   STD   2,U
   JMP   <fetch

opLESSTHANOREQUAL
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BGT   outFALSE
   BLT   outTRUE
   LDD   -2,U
   SUBD  2,U
   BPL   outFALSE
outTRUE
   LDD   #0          ; write 1 on top of stack
   STD   ,U
   INCB
   STD   2,U
   JMP   <fetch

opULESSTHAN
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BLO   outTRUE
   BHI   outFALSE
   LDD   -2,U
   SUBD  2,U
   BMI   outTRUE
   BRA   outFALSE

opULESSTHANOREQUAL
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BHI   outFALSE
   BLO   outTRUE
   LDD   -2,U
   SUBD  2,U
   BHI   outFALSE
   BRA   outTRUE

opEQ
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BNE   outFALSE
   LDD   -2,U
   SUBD  2,U
   BNE   outFALSE
   BRA   outTRUE

opNEQ
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BNE   outTRUE
   LDD   -2,U
   SUBD  2,U
   BNE   outTRUE
   BRA   outFALSE

***************************************
* SHIFT
***************************************

LSHIFTRIGHT MACRO
   LSRA
   RORB
   ROR   1,U
   ROR   2,U
   ENDM

opLSHIFTRIGHT
   LEAU  4,U
   LDD   ,U
   BEQ   opLSHIFTRIGHT_
   LSR  -1,U
   BCC   opLSHIFTRIGHT2
   LSHIFTRIGHT
opLSHIFTRIGHT2
   LSR   -1,U
   BCC   opLSHIFTRIGHT4
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT4
   LSR   -1,U
   BCC   opLSHIFTRIGHT8
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT8
   STD   ,U
   LSR   -1,U
   BCC   opLSHIFTRIGHT16
   LDD   1,U
   STD   2,U
   CLRA
   LDB   ,U
   STD   ,U
opLSHIFTRIGHT16
   LSR   -1,U
   BCC   opLSHIFTRIGHT32
   LDD   ,U
   STD   2,U
   LDD   #0
   STD   ,U
opLSHIFTRIGHT32
   JMP   <fetch

LSRD  MACRO
   LSRA
   RORB
   ENDM

opLSHIFTRIGHT_
   LDD   2,U
   LSR  -1,U
   BCC   opLSHIFTRIGHT_2
   LSRD
opLSHIFTRIGHT_2
   LSR   -1,U
   BCC   opLSHIFTRIGHT_4
   LSRD
   LSRD
opLSHIFTRIGHT_4
   LSR   -1,U
   BCC   opLSHIFTRIGHT_8
   LSRD
   LSRD
   LSRD
   LSRD
opLSHIFTRIGHT_8
   LSR   -1,U
   BCC   opLSHIFTRIGHT_16
   TFR   A,B
   CLRA
opLSHIFTRIGHT_16
   LSR   -1,U
   BCC   opLSHIFTRIGHT_32
   LDD   #0
opLSHIFTRIGHT_32
   STD   2,U
   JMP   <fetch

ASHIFTLEFT MACRO
   LSLB
   ROLA
   ROL   1,U
   ROL   ,U
   ENDM

opASHIFTLEFT
   LEAU  4,U
   LDD   2,U
   BEQ   opASHIFTLEFT_
   LSR  -1,U
   BCC   opASHIFTLEFT2
   ASHIFTLEFT
opASHIFTLEFT2
   LSR  -1,U
   BCC   opASHIFTLEFT4
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT4
   LSR  -1,U
   BCC   opASHIFTLEFT8
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT8
   STD   2,U
   LSR  -1,U
   BCC   opASHIFTLEFT16
   LDD   1,U
   STD   ,U
   LDA   3,U
   CLRB
   STD   2,U
opASHIFTLEFT16
   LSR  -1,U
   BCC   opASHIFTLEFT32
   LDD   2,U
   STD   ,U
   LDD   #0
   STD   2,U
opASHIFTLEFT32
   JMP   <fetch

LSLD  MACRO
   LSLB
   ROLA
   ENDM

opASHIFTLEFT_
   LDD   ,U
   LSR  -1,U
   BCC   opASHIFTLEFT_2
   LSLD
opASHIFTLEFT_2
   LSR  -1,U
   BCC   opASHIFTLEFT_4
   LSLD
   LSLD
opASHIFTLEFT_4
   LSR  -1,U
   BCC   opASHIFTLEFT_8
   LSLD
   LSLD
   LSLD
   LSLD
opASHIFTLEFT_8
   LSR  -1,U
   BCC   opASHIFTLEFT_16
   TFR   B,A
   CLRB
opASHIFTLEFT_16
   LSR  -1,U
   BCC   opASHIFTLEFT_32
   LDD   #0
opASHIFTLEFT_32
   STD   ,U
   JMP   <fetch

ASHIFTRIGHT MACRO
   ASRA
   RORB
   ROR   1,U
   ROR   2,U
   ENDM

opASHIFTRIGHT
   LEAU  4,U
   LDD   ,U
   LSR  -1,U
   BCC   opASHIFTRIGHT2
   ASHIFTRIGHT
opASHIFTRIGHT2
   LSR   -1,U
   BCC   opASHIFTRIGHT4
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT4
   LSR   -1,U
   BCC   opASHIFTRIGHT8
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT8
   STD   ,U
   LSR   -1,U
   BCC   opASHIFTRIGHT16
   LDD   1,U
   STD   2,U
   LDB   ,U
   SEX
   STD   ,U
opASHIFTRIGHT16
   LSR   -1,U
   BCC   opASHIFTRIGHT32
   LDB   ,U
   SEX
   TFR   A,B
   STD   ,U
   STD   2,U
opASHIFTRIGHT32
   JMP   <fetch

opCALL
   LDD   ,U
   LDX   2,U
   PSHS  D,X
   LDA   <PC_HI+1
   ANDA  #-$30
   STA   ,U
   LDD   <PC_LO
   ANDA  #$30
   ORA   ,U
   STD   2,U
   CLRA
   LDB   <PC_HI
   STD   ,U
   LDD   1,S
   STD   <PC_HI
   LDD   2,S
   ANDA  #$3F
   ADDA  #$A0
   STD   <PC_LO
   LEAS  4,S
   JMP   <updatePC

basicOPs
   FDB   opBREAKPT   ; %0000
   FDB   opUNK       ; %0001
   FDB   opPUSHSP    ; %0010
   FDB   opUNK       ; %0011
   FDB   opPOPPC     ; %0100
   FDB   opADD       ; %0101
   FDB   opAND       ; %0110
   FDB   opOR        ; %0111
   FDB   opLOAD      ; %1000
   FDB   opNOT       ; %1001
   FDB   opFLIP      ; %1010
   FDB   opNOP       ; %1011
   FDB   opSTORE     ; %1100
   FDB   opPOPSP     ; %1101
   FDB   opUNK       ; %1110
   FDB   opUNK       ; %1111

extendedOPs
   FDB   opLOADH     ; 34
   FDB   opSTOREH    ; 35
   FDB   opLESSTHAN  ; 36
   FDB   opLESSTHANOREQUAL  ; 37
   FDB   opULESSTHAN ; 38
   FDB   opULESSTHANOREQUAL ; 39
   FDB   opSWAP      ; 40
   FDB   opMULT      ; 41
   FDB   opLSHIFTRIGHT      ; 42
   FDB   opASHIFTLEFT       ; 43
   FDB   opASHIFTRIGHT      ; 44
   FDB   opCALL      ; 45
   FDB   opEQ        ; 46
   FDB   opNEQ       ; 47
   FDB   opNEG       ; 48
   FDB   opSUB       ; 49
   FDB   opXOR       ; 50
   FDB   opLOADB     ; 52
   FDB   opSTOREB    ; 52
   FDB   opDIV       ; 53
   FDB   opMOD       ; 54
   FDB   opUNK       ; 55
   FDB   opUNK       ; 56
   FDB   opUNK       ; 57
   FDB   opUNK       ; 58
   FDB   opUNK       ; 59
   FDB   opUNK       ; 60
   FDB   opUNK       ; 61
   FDB   opUNK       ; 62
   FDB   opUNK       ; 63
   FDB   opUNK       ; 64
   FDB   opUNK       ; 65
   FDB   opUNK       ; 66
   FDB   opUNK       ; 67
   FDB   opUNK       ; 68
   FDB   opUNK       ; 69

   END
