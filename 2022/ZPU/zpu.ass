(main)zpu
   ORG   $7000

STACK_SWAP  SET   0           ; swap words on stack (produces faster implem for some opcodes)
SAFE        SET   0           ; force long addressing for long ops (slower)
TRACE       SET   0           ; traces executed instructions
LPR         SET   0           ; also output result to printer on parallel port
CYCLE_TIMER SET   0           ; timer based on cycle (costly) or rtc (accurate) ?

FIRST_PAGE  SET   2           ; address 0 is mapped to that page
STACK_SIZE  SET   2048        ; size of stack
IO_SPACE    SET   $0800       ; address above IO_SPACE:00000 are IO related (value chosen for Phi board)
STK_SPACE   SET   IO_SPACE-1  ; high word of unmapped zone (make sure it is below IO_SPACE)

***************************************
* System equates
***************************************
PUTC  EQU   $E803             ; prints a char
GETC  EQU   $E806             ; reads the keybord
RSOPC EQU   $602B             ; serial/parallel command
RSCO  EQU   $E812             ; serial/parallel execute
LGA5  EQU   $E7E5             ; reg for memory bank at $A000-$DFFF
LGA6  EQU   $E7E6             ; reg for memory bank at $0000-$3FFF
LGA7  EQU   $E7E7             ; Gate Array "mode page"

COLOR MACRO
  IFEQ  LPR
   FCB   27,$40+\0
  ENDC
   ENDM

ASRD  MACRO
   ASRA
   RORB
   ENDM

LSRD  MACRO
   LSRA
   RORB
   ENDM

LSLD  MACRO
   LSLB
   ROLA
   ENDM

***************************************
* Byte order on stack (word-swapped)
***************************************
  IFEQ STACK_SWAP
B0 EQU   $00
B1 EQU   $01
B2 EQU   $02
B3 EQU   $03

B4 EQU   $04
B5 EQU   $05
B6 EQU   $06
B7 EQU   $07
  ELSE
B0 EQU   $02         ; 2301
B1 EQU   $03
B2 EQU   $00
B3 EQU   $01

B4 EQU   $06         ; 6745
B5 EQU   $07
B6 EQU   $04
B7 EQU   $05
  ENDC
BX MACRO QUIET
  IFEQ B\1
   \0   ,X
  ELSE
   \0   B\1,X
  ENDC
  ENDM

BU MACRO QUIET
  IFEQ B\1
   \0   ,U
  ELSE
   \0   B\1,U
  ENDC
  ENDM

BU_LDD MACRO QUIET
  IFEQ ((B\1)-(B\0)-1)
   BU   LDD,\0
  ELSE
   BU   LDA,\0
   BU   LDB,\1
  ENDC
  ENDM

BU_STD MACRO QUIET
  IFEQ ((B\1)-(B\0)-1)
   BU   STD,\0
  ELSE
   BU   STA,\0
   BU   STB,\1
  ENDC
  ENDM

main
   LEAS  main,PCR

   LDD   #PAGE0+$1000
   TFR   B,DP
   SETDP PAGE0

   ORA   >$6081      ; Activate
   STA   >$6081      ; direct
   STA   >LGA7       ; RAM

   LDA   >$E000      ; $E00 sentinel
   BPL   okROM
   JSR   PUTSTR
   FCC   /ERROR ROM BYTE @$E000 < /
   FCB   128+'0
   SWI
   BRA   *
okROM
   LDX   #opTable
   LSLA
   LEAX  A,X
   LDD   ,X
   STD   <rom_OP+1
   LDD   #rom_OP_chk
   STD   ,X

   BSR   INITLPR
   BSR   INITMEMORY

   LDX   #FILENAME
   JSR   LOADFILE

   JSR   INITTIMER

GOZPU
   LDU   #$A000-8    ; set stack ptr
   STU   <page       ; force page to be out of address space
   LDD   #0
   LDX   #0
   PSHU  D,X         ; push address $0000 0000
   JMP   opPOPPC     ; and off we go

INITLPR
   IFNE  LPR         ; open parallel port
   LDB   #$40
   STB   >RSOPC
   JSR   >RSCO
   LDB   #$08        ; to write bytes
   STB   >RSOPC
   LDB   #12
   JMP   >RSCO
   ELSE
   RTS
   ENDC

***************************************
* MEMORY
***************************************
LAST_PAGE
   FCB   0

INITMEMORY
   BSR   FINDMAX        ; guess LAST_PAGE
   BSR   PRINTMAX       ; prints a message about it
   LDX   #$A000
   LDA   LAST_PAGE      ; clear all banks starting from the last one
CLRPAGES
   STA   LGA5           ; update bank
   CMPA  #FIRST_PAGE    ; first page ?
   BEQ   CLRHEAP        ; yes => only clear HEAP data
   BSR   CLRMEM         ; no => clear $A000..$DFFF
   DECA                 ; next page
   BRA   CLRPAGES
CLRHEAP
   LDX   #FAT
   * BRA   CLRMEM

CLRMEM
   PSHS  D,X         ; clears a memory zone upto $E000
   LDD   #0
   BRA   CLRMEM2
CLRMEM1
   STD   ,X
   STD   2,X
   STD   4,X
   STD   6,X
   STD   8,X
   STD   10,X
   STD   12,X
   STD   14,X
   LEAX  16,X
CLRMEM2
   CMPX  #$E000-16
   BLS   CLRMEM1
   BRA   CLRMEM4
CLRMEM3
   STB   ,X+
CLRMEM4
   CMPX  #$E000
   BLO   CLRMEM3
   PULS  D,X,PC
FINDMAX
   PSHS  D,X            ; find maximum page (LAST_PAGE)
   LDX   #$A000
   LDD   #FIRST_PAGE-1
FINDMAX1
   INCB
   CMPB  #$20
   BEQ   FINDMAX3
   STB   LGA5
   STB   ,X
FINDMAX2
   BSR   CHKSIG         ; check sucessfull writing of 256 random values at X
   BNE   FINDMAX3       ; if one fails cut scan here
   DECA                 ; decrement
   BNE   FINDMAX2       ; 256 success ? no=>loop
   BRA   FINDMAX1       ; yes => valid bank, try next one
FINDMAX3
   DECB
   STB   LAST_PAGE
   PULS  D,X,PC

CHKSIG
   PSHS  D           ; suffle bits (multiply by 5)
   LDA   ,X
   LDB   #5
   MUL
   STB   ,X
   LDB   1,X
   LDA   #5
   MUL
   ORB   #1
   ADDA  ,X
   STD   ,X
   SUBD  ,X          ; $5FFE is mapped on $DFFE when we wrapped around the number of pages
   PULS  D,PC

PRINTMAX
   PSHS  D
   JSR   PUTSTR
   FCB   12
   FCC   /Found/
   FCB   128+32
   LDB   LAST_PAGE
   SUBB  #FIRST_PAGE-1
   JSR   DECIMAL
   JSR   PUTSTR
   FCC   /x16k free memory/
   FCB   13,10+128
   PULS  D,PC

PUTS
   PSHS  B        ; prints a 0 or neg-terminated string pointed by X (updated)
   BRA   PUTS1
PUTS0
   BSR   PUTCHAR
PUTS1
   LDB   ,X+
   BEQ   PUTS2
   BPL   PUTS0
   ANDB  #127
   BSR   PUTCHAR
PUTS2
   PULS  B,PC

PUTSTR
   PSHS  X           ; prints the string follwing the call
   LDX   2,S
   BSR   PUTS
   STX   2,S
   PULS  X,PC

HEX32
   BSR   HEX16       ; prints 32 bits value at X (incremented)
HEX16
   BSR   HEX8        ; prints 16 bits value at X (incremented)
HEX8
   LDB   ,X+         ; prints 8 bits value at X (incremented)
   * BRA   HEX
HEX
   BSR   HEX0        ; print B in hexa (A trashed)
   EXG   A,B
HEX0
   LDA   #$10
   MUL
   ADDA  #$90
   DAA
   ADCA  #$40
   DAA
   EXG   A,B
PUTCHAR
  IFNE  LPR
   IFEQ  TRACE
   JSR   PUTC
   ENDC
   JMP   RSCO
  ELSE
   JMP   PUTC              ; prints a character (in B)
  ENDC

DECIMAL
   STB   ,-S               ; prints a signed byte in decimal
   BPL   DECIMAL1
   NEG   ,S
   BSR   PUTSTR
   FCB   128+'-
DECIMAL1
   CLRA
   LDB   #8
DECIMAL2
   LSL   ,S
   STA   ,-S
   ADCA  ,S+
   DAA
   DECB
   BNE   DECIMAL2
   STA   ,S
   BCC   DECIMAL3
   BSR   PUTSTR
   FCB   128+'1
   LDB   ,S+
   BRA   HEX8
DECIMAL3
   LDB   ,S
   LSRB
   LSRB
   LSRB
   LSRB
   BEQ   DECIMAL4
   ADDB  #'0
   BSR   PUTCHAR
DECIMAL4
   LDB   ,S+
   ANDB  #15
   ADDB  #'0
   BRA   PUTCHAR

LOADFILE
   PSHS  A,X,U
   BSR   PUTSTR
   FCC   /Loading/
   FCB   32+128
   BSR   PRINTFN
   BSR   PUTSTR
   FCC   /../
   FCB   128+'.
   LDA   #FIRST_PAGE
   LDX   1,S
   LDU   #$A000
   BSR   LOAD
   BSR   PUTSTR
   FCC   /done/
   FCB   13,10,13,10+128
   PULS  A,X,U,PC
PRINTFN
   PSHS  D,X,U
   LDA   #8
   LDB   1,X
   CMPB  #':
   BNE   PRINTFN1
   ADDA  #2
PRINTFN1
   LEAU  A,X
PRINTFN2
   DECA
   BMI   PRINTFN3
   LDB   A,X
   CMPB  #32
   BEQ   PRINTFN2
   INCA
   BSR   PRINTFN4
PRINTFN3
   LEAX  ,U
   LDD   #3*256+'.
   JSR   PUTCHAR
   BSR   PRINTFN4
   PULS  D,X,U,PC
PRINTFN4
   LDB   ,X+
   JSR   PUTCHAR
   DECA
   BNE   PRINTFN4
   RTS

*--------------------------------------*|*
  * Module de chargement pour un fichier *
  * Entrees:                             *
  * A = BANK                             *
  * X = Pointeur sur nom de fichier      *
  * U = Adresse d'implantation           *
  *--------------------------------------*
*DKOPC equ    $6048  ; operation d7
DKDRV EQU   $6049    ; lecteur
DKTRK EQU   $604A    ; piste (2 ocets)
DKSEC EQU   $604C    ; secteur
DKSTA EQU   $604E    ; status d7
DKBUF EQU   $604F    ; buf i/o
DKCAT EQU   $60E9    ; ptr catalogue
DKNAM EQU   $60E7    ; nom fichier
DKTYP EQU   $60EB    ; type fichier (2octets)
DKFAT EQU   $60ED    ; ptr fat
DKMOD EQU   $60F0    ; mode d'acces
DKFIN EQU   $60F3    ; dernier bloc
DKBLK EQU   $60F6    ; 1er bloc fichier
DKTDS EQU   $60F7    ; nb octets dern sect (2octets)
DKIFA EQU   $60F9    ; secteur fat fichier
LECFA EQU   $E00D    ; lecture fat
RECFI EQU   $E010    ; recherche fichier
CONVB EQU   $E01F    ; converison bloc
DKCOM EQU   $E82A    ; commande d7
LOAD
   PSHS  D,X,U,DP    ; Load a file from minidos
   STA   LGA5        ; set bank
   PSHS  A           ; set BANK cpt
   SETDP $60
   LDD   #$6000
   TFR   A,DP
   STB   DKDRV
   LDA   1,X
   CMPA  #':
   BNE   LOAD00
   LDA   ,X++
   SUBA  #'0
   STA   DKDRV
LOAD00
   LDA   #$02     A=2, B=$00
   STB   DKSTA    Efface erreur
   STB   $6025   ; FIX COPBUF
   STD   DKTYP    Type de fichier
   STX   DKNAM    Nom du fichier
   STU   LDPTR    Adr d'implantation
* Chargement de la FAT
   LDX   #BUF
   STX   DKCAT
   LDX   #FAT
   STX   DKFAT
   JSR   LECFA    Charge la FAT
   BCS   ERRIO    Si "I/O Error"
* Recherche du fichier
   LDA   #1       | Initialise
   STA   DKMOD    | en LOAD
   JSR   RECFI    Recherche fichier
   TST   DKIFA    | Si $60F9 = 0,
   BEQ   ERRNF    | fich non trouve'
* Convertit numero de bloc
LOAD0
   JSR   CONVB    Convertit bloc
   STB   DKTRK+1  Initialise piste
   LDX   DKFAT    Pointeur sur FAT
   LDB   DKBLK    Bloc courant
   INCB           | Bloc
   LDB   B,X      | suivant
   STB   DKBLK    Sauve le bloc
   CMPB  #$C0     | Si dernier bloc,
   BHI   LOAD1    | recupere taille
   LDB   #$08     8 secteurs a charg
LOAD1
   ANDB  #$0F     Isole taille bloc
   STA   DKSEC    Sauve premier bloc
   ADDB  DKSEC    Ajoute depart bloc
   DECB           Ajuste dern bloc
   STB   DKFIN    Sauve dernier bloc
* Charge les secteurs
LOAD2
   JSR   DKCOM    Charge le secteur
   BCS   ERRIO    Si "I/O Error"
   LDA   $604C    | Si secteur pas
   CMPA  DKFIN    | secteur maximum,
   BNE   LOAD3    | passe
   LDA   DKBLK    | Si dernier
   CMPA  #$C0     | secteur du
   BHI   LOAD4    | fichier, sort
   BSR   TFR      Transfere donnees
   BRA   LOAD0    Bloc suivant
LOAD3
   BSR   TFR      Transfere donnees
   INC   $604C    Secteur + 1
   BRA   LOAD2    Secteur suivant
* Chargement dernier secteur et sortie
LOAD4
   LDD   DKTDS    Taille dern sect
   BEQ   LOAD5    Si 0, sort
   BSR   TFR0     Transfere donnees
LOAD5
   CLRA           efface carry
LOAD6
   LDD   ,S+      ; fixe cpt BANK
   STB   LGA5     ; restore init BANK
   PULS  D,X,U,DP,PC
ERRIO
   JSR   PUTSTR
   FCB   13,10
   FCC   /IO ERROR/
   FCB   7+128
ERRLOOP
   BRA   ERRLOOP
ERRNF
   JSR   PUTSTR
   FCB   13,10
   FCC   /FILE NOT FOUND/
   FCB   7+128
   BRA   ERRLOOP
ERROM
   LEAS  2,S
   JSR   PUTSTR
   FCB   13,10
   FCC   /OUT OF MEMORY/
   FCB   7+128
   BRA   ERRLOOP
* Transfert des donnees
TFR
   LDB   $6058   | Ajuste taille
   COMB          | maximum du
   ORB   #$80    | secteur
TFR0
   LDX   #0      Recupere ptr mem
LDPTR SET   *-2
   LEAU  ,X
   ABX
   CMPX  #$E000
   LEAX  ,U
   LDU   DKBUF   Ptr buffer secteur
   BCC   TFRslow
TFRfast
   LDA   ,U+     |
   STA   ,X+     | Transfere
   DECB          | les donnees
   BNE   TFRfast |
TFR1
   STX   LDPTR   Sauve implantation
   RTS
TFRslow
   LDA   ,U+     |
   STA   ,X+     | Transfere
   CMPX  #$E000
   BEQ   TFRslow2
   DECB          | les donnees
   BNE   TFRslow |
   BRA   TFR1
TFRslow2
   LDX   #$A000
   LDA   3,S
   INCA
   CMPA  LAST_PAGE
   BHI   ERROM
   STA   3,S
   STA   LGA5
   DECB          | les donnees
   BNE   TFRfast
   BRA   TFR1

   SETDP 0

***************************************
* Timer
***************************************
TIMEPT   EQU   $6027
STATUS   EQU   $6019
KBIN     EQU   $E830

TIMER_CTR
   FDB   0        ; timer counter (64 bits)
   FDB   0
   FDB   0
   FDB   0

INITTIMER
   PSHS  D,X      ; init timer
   ORCC  #$50
   LDD   #0
   LDX   #0
   LDU   #TIMER_CTR+8
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
  IFEQ  CYCLE_TIMER
   LDX   #TIMERINTER
   STX   TIMEPT
   LDA   STATUS
   ORA   #%00100000
   STA   STATUS
  ENDC
   ANDCC #$FF-$50
   PULS  D,X,PC

* 100 ms = 100 000 us
*        = $1 86A0
   IFNE  CYCLE_TIMER
TINC2 SET 0
TINC1 SET 1
   ELSE
TINC2 SET $1
TINC1 SET $86A0
   ENDC
TIMERINTER
   IFNE  CYCLE_TIMER
   PSHS  D,X
   ENDC
   LDX   #TIMER_CTR+4
   LDD   #TINC1
   ADDD  2,X
   STD   2,X
   LDD   ,X
   ADCB  #TINC2
   ADCA  #0
   STD   ,X
   BCC   TIMERINTERX
   LDD   -2,X
   ADCB  #0
   ADCA  #0
   STD   -2,X
   BCC   TIMERINTERX
   LDD   -4,X
   ADCB  #0
   ADCA  #0
   STD   -4,X
TIMERINTERX
   IFNE  CYCLE_TIMER
   PULS  D,X,PC
   ELSE
   JMP   KBIN
   ENDC

   ORG   ((*+255)/256)*256
PAGE0   SET   */256
   SETDP PAGE0

FETCH_INSTRUCTION MACRO
   IFNE  TRACE
   JSR   doTRACE
   ENDC
   LDB   ,Y+         ; fetch next instruction code
   ENDM

* SAFE version of getAddr for long values
getAddrL
   IFNE  SAFE
   LDB   #%11111100
   BU ANDB,3         ; just clear the 2 lower bits of TOS
   BU STB,3
   ENDC

* make page and X points to the address in TOS (stack unmodified)
getAddr
   BU LDA,0          ; speedup: if nul then adress is mapped
   BEQ   getAddrMapped
   BU LDX,2
   RTS
getAddrMapped
   BU LDD,2          ; load lower part of the address
   ANDA  #$3F        ; clear high bits
   ADDA  #$A0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X updated
   BU_LDD 1,2        ; load 16kb page section of address

* updates page when neeeded
* D=high bytes of the 24bits address
updatePage
   ANDB  #$C0        ; just keep the 2 top bits
   CMPD  #page       ; compare with current page index
page equ *-2         ; page index (dynamic code)
   BEQ   donePage    ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA
* map proper BANk onto $A000...$DFFF space
* A=BANk number
chgBANK
   ADDA  #FIRST_PAGE
   STA   LGA5        ; need to check, might use PIA instead
donePage
   RTS               ; done

nxtPage
   PSHS  B           ; preserve opcode
   LDD   <PC_PG      ; load PC page
   ADDD  #$40        ; adds 16kb
   STD   <PC_PG      ; update PC page
   JSR   <updatePage ; update BANk
   LDY   #$A000      ; go to start of page
   PULS  B,PC        ; restore opcode

  IFNE CYCLE_TIMER
decode_pos SET decode
  ELSE
decode_pos SET decode_
  ENDC

opIM
  IFNE B0-0
* loads a 7 bit immediate value
* B=xxxxxxx0 (value*2)
   LSLB              ; [2]
   ASRB              ; [2] left align signed value
   SEX               ; [2] extend sign to A
   PSHU  D           ; [7]
   PSHU  D           ; [7] At this point B0,B2,B3 are ok
   STA   B1,U        ; [5] == [25] fix B1
  ELSE
   BITB  #%01000000  ; [2]
   BEQ   opIMpos     ; [3]
   LDX   #$FF00      ; [3]
   ABX               ; [3]
   LDD   #-1         ; [3]
   PSHU  D,X         ; [9] = [23]
   FETCH_INSTRUCTION
   BPL   decode_pos
   BRA   opIM2
opIMpos
   LDX   #$FF80      ; [3]
   ABX               ; [3]
   LDD   #0          ; [3]
   PSHU  D,X         ; [9] = [23]
   FETCH_INSTRUCTION
   BPL   decode_pos
  ENDC

opIM2
   LSLB
   LDA   B3,U
   ASRA
   RORB
   BU STD,2

   FETCH_INSTRUCTION
   BPL   decode_pos

opIM3
   LSLB
   BU LDA,2
   ASRA
   STA   B1,U
   LDA   B3,U
   RORA
   RORB
   BU STD,2

   FETCH_INSTRUCTION
   BPL   decode_pos

* loads a continuated immediate value
* B=xxxxxxx0 (value*2)
opIM_loop
   LSLB
   BU LSR,0          ; rotate TOS 7 bits left and add B/2 at the bottom
   BU LDA,1
   RORA
   BU STA,0          ; byte 0 is byte 1 rotated right once
   BU LDA,2
   RORA
   BU STA,1          ; byte 1 is byte 2 rotated right once
   BU LDA,3
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   BU STD,2          ; write lower word

   FETCH_INSTRUCTION
   BMI   opIM_loop
   BRA   decode_pos

* restore the page back to the instruction page
updatePC
   LDD  #PC_PG       ; load instruction page
PC_PG SET *-2        ; instruction page (dynamic code)
updatePC_D
   JSR  <updatePage  ; update page if needed
   
NEXT MACRO
  IFEQ 1
    JMP  <fetch
  ELSE
   FETCH_INSTRUCTION
  IFNE  CYCLE_TIMER
   JSR   TIMERINTER
  ENDC
   LBMI   opIM       ; opcode=1xxxxxxx ? yes => immediate value
   LDX   #opTable
   LSLB              ; decode the opcode
   JMP   [B,X]       ; jump to instruction
  ENDC
  ENDM
  

* fetches and execute an instruction
opNOP
fetch
   FETCH_INSTRUCTION
decode
  IFNE  CYCLE_TIMER
   JSR   TIMERINTER
  ENDC
   BMI   opIM        ; opcode=1xxxxxxx ? yes => immediate value
decode_
   LDX   #opTable
   LSLB              ; decode the opcode
   JMP   [B,X]       ; jump to instruction
   
rom_OP_chk
   CMPY  #$E000      ; check page change
   BLO   rom_OP      ; no => just decode inwtruction
   JSR   <nxtPage
   BRA   fetch
rom_OP
   JMP   >opBREAKPT
   
sampledTMR
   FDB   0,0,0,0     ; sampled timer

***************************************
* ARITHMETIC
***************************************

opSUB
   LEAX  ,U
   BSR   neg_x
   * BRA   opADD

opADD
   LDD   ,U++
   BEQ   opADD1
   ADDD  2,U
   STD   2,U
opADD1
   PULU  D
   ADDD  2,U
   STD   2,U
   BCC   fetch
   INC   1,U
   BNE   fetch
   INC   ,U
opADD2
   NEXT

neg_x
   LDD   #0
   BX SUBD,2
   BX STD,2
   LDD   #0
   BCC   neg_x1
   LDD   #-1
neg_x1
   BX SUBD,0
   BX STD,0
   RTS

opNEG
   LEAX  ,U
   BSR   neg_x
   NEXT

opDIV
   CLR   ,-S            ; clear sign bit
   LEAX  ,U
   BX LDB,0
   BPL   opDIV1
   COM   ,S             ; negate sign
   JSR   <neg_x         ; negate dividend
opDIV1
   LEAX  4,U
   BX LDB,0
   BPL   opDIV2
   COM   ,S             ; negate sign
   JSR   <neg_x         ; negate divisor
opDIV2
   BSR   UDIV32
   LEAX  4,U
   BU LDD,0
   COMA
   COMB
   BX STD,0
   BU LDD,2
   COMA
   COMB
opDIV4
   BX STD,2
   LEAU  ,X             ; fix stack
   LDB   ,S+            ; test sign
   BPL   opDIV3         ; positive => no chg
   JSR   <neg_x         ; negate result
opDIV3
   JMP   <fetch

opMOD
   LEAX  ,U
   BX LDB,0
   STB   ,-S            ; store sign
   BPL   opMOD1
   JSR   <neg_x         ; negate dividend
opMOD1
   LEAX  4,U
   BX LDB,0
   BPL   opMOD2
   JSR   <neg_x         ; negate divisor
opMOD2
   BSR   UDIV32
   LEAX  4,U
   LDD   -4,U
   BX STD,0
   LDD   -2,U
   BRA   opDIV4

* https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder
UDIV32
   LDD   #0
   STD   -4,U           ; R=0
   STD   -2,U
   LDX   #32
UDIV32_1
   BU ROL,3             ; N = N<<1
   BU ROL,2
   BU ROL,1
   BU ROL,0             ; carry = N(i)
   LDD   -2,U
   ROLB                 ; inject N(i)
   ROLA
   STD   -2,U
   ROL   -3,U
   ROL   -4,U           ; R = {R<<1 | N(i)}
   BU SUBD,6            ; R-D (low)
   STD   -6,U           ; save temp
   LDD   -4,U
   BU SBCB,5
   BU SBCA,4            ; R-D (high)
   BCS   UDIV32_2       ; R-D<0 ? yes => no chg
   STD   -4,U           ; R = R-D (high)
   LDD   -6,U           ; retrieve temp
   STD   -2,U           ;     R-D (low)
UDIV32_2
   LEAX  -1,X
   BNE   UDIV32_1
   BU ROL,3             ; inject last comparison bit
   BU ROL,2
   BU ROL,1
   BU ROL,0
   RTS

M07 EQU  B0*256+B7
M17 EQU  B1*256+B7
M27 EQU  B2*256+B7
M16 EQU  B1*256+B6
M26 EQU  B6*256+B2
M36 EQU  B6*256+B3
M25 EQU  B5*256+B2
M34 EQU  B4*256+B3
M35 EQU  B5*256+B3

opMULT
   LDD   #0          ; clear upper word
   STD   -4,U
   LDA   B3,U
   LDB   B7,U        ; compute byte #4
   MUL               ; 3+7
   STD   -2,U
   LEAX  -3,U        ; compute byte #3
   LDD   #M27        ; 2+7
   BSR   MULT1
   LDD   #M36        ; 3+6
   BSR   MULT1
   LEAX  -4,U        ; compute byte #2
   LDD   #M17        ; 1+7
   BSR   MULT2
   LDD   #M26        ; 2+6
   BSR   MULT2
   LDD   #M35        ; 3+5
   BSR   MULT2
   LDD   #M07        ; compute byte #1
   BSR   MULT3       ; 0+7
   LDD   #M16
   BSR   MULT3       ; 1+6
   LDD   #M25
   BSR   MULT3       ; 2+5
   LDD   #M34
   BSR   MULT3       ; 3+4
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   BU STD,0
   LDD   2,X
   BU STD,2
   JMP   <fetch
MULT1
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   BCC   MULT0
   INC   -1,X
MULT0
   RTS
MULT2
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   RTS
MULT3
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDB  ,X
   STB   ,X
   RTS

opMULT16X16
   LDD   #0          ; clear upper word
   STD   -4,U        ; 2301
   LDA   B3,U        ; 6745
   LDB   B7,U
   MUL               ; compute byte #4
   STD   -2,U        ; 3+7
   LEAX  -3,U
   LDD   #M27        ; compute byte #3
   BSR   MULT1       ; 2+7
   LDD   #M36        ; 3+6
   BSR   MULT1
   LEAX  -4,U
   LDD   #M26        ; compute byte #2
   BSR   MULT2       ; 2+6
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   2,U
   LDD   2,X
   STD   ,U
   JMP   <fetch

***************************************
* Load on stack the value at stack[x]
* B=--xxxxx0 (2*x)
***************************************


opLOADSP_0
   LDD   ,U
   LDX   2,U
   PSHU  D,X
   NEXT

opLOADSP_ MACRO
opLOADSP_\0
   LDD   4*\0,U
   LDX   4*\0+2,U
   PSHU  D,X
   LDB   ,Y+
   BMI   opIMx\0
   LDX   #opTable
   LSLB
   JMP   [B,X]
opIMx\0
   JMP   <opIM
   ENDM

   opLOADSP_ 1
   opLOADSP_ 2
   opLOADSP_ 3
   opLOADSP_ 4
   opLOADSP_ 5
   opLOADSP_ 6
   opLOADSP_ 7
   opLOADSP_ 8
   opLOADSP_ 9
   opLOADSP_ 10
   opLOADSP_ 11
   opLOADSP_ 12
   opLOADSP_ 13
   opLOADSP_ 14
   opLOADSP_ 15
   opLOADSP_ 16
   opLOADSP_ 17
   opLOADSP_ 18
   opLOADSP_ 19
   opLOADSP_ 20
   opLOADSP_ 21
   opLOADSP_ 22
   opLOADSP_ 23
   opLOADSP_ 24
   opLOADSP_ 25
   opLOADSP_ 26
   opLOADSP_ 27
   opLOADSP_ 28
   opLOADSP_ 29
   opLOADSP_ 30
   opLOADSP_ 31

opLOADSP_x
   LSLB              ; B ~ x*4
   EORB  #%01000000
   ANDB  #%01111100  ; clear bit 7 of 4*x
   LEAX  B,U         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHU  D,X         ; push 32 bits
   JMP   <fetch      ; next instruction

***************************************
* Write top of stack at stack[x]
* B=00xxxxx0 (2*x)
***************************************

opSTORESP_0
   LEAU  4,U
   NEXT

opSTORESP_1
   PULU  D,X
   STD   ,U
   STX   2,U
   NEXT

opSTORESP_ MACRO
opSTORESP_\0
   PULU  D,X
   STD   4*\0-4,U
   STX   4*\0-2,U
   NEXT
   ENDM

   opSTORESP_ 2
   opSTORESP_ 3
   opSTORESP_ 4
   opSTORESP_ 5
   opSTORESP_ 6
   opSTORESP_ 7
   opSTORESP_ 8
   opSTORESP_ 9
   opSTORESP_ 10
   opSTORESP_ 11
   opSTORESP_ 12
   opSTORESP_ 13
   opSTORESP_ 14
   opSTORESP_ 15
   opSTORESP_ 16
   opSTORESP_ 17
   opSTORESP_ 18
   opSTORESP_ 19
   opSTORESP_ 20
   opSTORESP_ 21
   opSTORESP_ 22
   opSTORESP_ 23
   opSTORESP_ 24
   opSTORESP_ 25
   opSTORESP_ 26
   opSTORESP_ 27
   opSTORESP_ 28
   opSTORESP_ 29
   opSTORESP_ 30
   opSTORESP_ 31

opSTORESP_x
   LSLB              ; B ~ x*4
   EORB  #%01000000
   LEAX  B,U         ; X point to dest (bit7 already 0)
   PULU  D           ; load low word
   STD   ,X          ; store low word
   PULU  D           ; load high word
   STD   2,X         ; store high word
   JMP   <fetch      ; next instruction

***************************************
* Adds to TOS the value at stack[x]
* B=0--xxxx00 (4*x)
***************************************

opADDSP_0
   BU LSL,3
   BU ROL,2
   BU ROL,1
   BU ROL,0
   NEXT

opADDSP_ MACRO
opADDSP_\0
   BU LDD,2          ; load low word of source
   BU ADDD,2+4*\0    ; add low word of TOS
   BU STD,2          ; store result to TOS (lower word)
   BU LDD,0+4*\0     ; load high word of source
*   BCS   opADDSPh\0  ; 3
*   BNE   opADDSPh\0  ; 3
*   JMP   <fetch      ; shortcut
*opADDSPh\0
   BU ADCB,1         ; add with carry the TOS (high word)
   BU ADCA,0         ; second byte
   BU STD,0          ; store result to TOS (high word)
   NEXT
   ENDM

   opADDSP_  1
   opADDSP_  2
   opADDSP_  3
   opADDSP_  4
   opADDSP_  5
   opADDSP_  6
   opADDSP_  7
   opADDSP_  8
   opADDSP_  9
   opADDSP_  11
   opADDSP_  12
   opADDSP_  13
   opADDSP_  10
   opADDSP_  14
   opADDSP_  15

opADDSP_x
   LSLB              ; B ~ 4*x
   ANDB  #%00111100  ; make 4*x postitive
   LEAX  B,U         ; X point to source
   BU LDD,2          ; load low word of source
   BX ADDD,2         ; add low word of TOS
   BU STD,2          ; store result to TOS (lower word)
   BU LDD,0          ; load high word of source
*   BCS   opADDSPh
*   BNE   opADDSPh
*   JMP   <fetch
*opADDSPh
   BX ADCB,1         ; add with carry the TOS (high word)
   BX ADCA,0         ; second byte
   BU STD,0          ; store result to TOS (high word)
   NEXT

***************************************

opUNKNOWN

opBREAKPT
   LDA   STATUS
   ANDA  #%11011111  ; disable timer interrupt
   STA   STATUS
   SWI               ; back to monitor

* Pushes stack address
opPUSHSP
  IFEQ B0-0
   LDD   #STK_SPACE  ; stack address is $01FF:9xxx
   LEAX  ,U
  ELSE
   LDX   #STK_SPACE  ; stack address is $01FF:9xxx
   TFR   U,D
  ENDC
   PSHU  D,X
   NEXT

opPUSHSPADD
   LDB  ,Y+
   CMPB #13
   BEQ  opPUSHSPADDPPOPSP
   BU LDD,2
   LSLD
   LSLD
   LEAX  D,U
   BU STX,2
   LDD   #STK_SPACE  ; stack address is $01FF:9xxx
   BU STD,0          ; BANk 0, $Dxxx
   LEAY  -1,Y
   NEXT
   
opPUSHSPADDPPOPSP
   BU LDD,2
   LSLD
   LSLD
   LEAU  D,U
   NEXT

***************************************
* LOGIC
***************************************

BITWISE MACRO
   PULU  D,X
   \0A  ,U
   \0B  1,U
   STD   ,U
   TFR   X,D
   \0A  2,U
   \0B  3,U
   STD   2,U
   NEXT
  ENDM

opAND
  IFEQ 1
   BITWISE AND       ; [44] bitwise "and" of TOS with NOS
  ELSE
   LDD   ,U++
   BEQ   opAND1
   ANDA  2,U
   ANDB  3,U
opAND1
   STD   2,U
   PULU  D
   ANDA  2,U
   ANDB  3,U
   STD   2,U
   NEXT
  ENDC

opOR
  IFEQ 1
   BITWISE OR        ; bitwise "or" of TOS with NOS
  ELSE
   LDD   ,U++
   BEQ   opOR1
   ORA   2,U
   ORB   3,U
   STD   2,U
opOR1
   PULU  D
   ORA   2,U
   ORB   3,U
   STD   2,U
   JMP   <fetch
  ENDC

opXOR
   BITWISE EOR       ; bitwise "xor" of TOS with NOS

opNOT
   COM   ,U          ; bitwise complement of TOS
   COM   1,U
   COM   2,U
   COM   3,U         ; 7*3+6=27
   NEXT

flip2
   LSRA              ; helper to flip A and B bits
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   RTS

opFLIP
   BU LDA,3          ; flips the bits of the TOS
   BU LDB,0
   BSR   flip2       ; 0/3
   BU STA,3
   BU STB,0
   BU_LDD 1,2
   BSR   flip2       ; 1/2
   BU_STD 1,2
   JMP   <fetch

opSWAP
   LDD   ,U
   LDX   2,U
   STX   ,U
   STD   2,U
   JMP   <fetch

***************************************
* MEMORY
***************************************

* https://github.com/zylin/zpu/blob/master/zpu/sw/startup/crt_io.c

* _cpu_config==0 => Abel
* _cpu_config==1 => Zeta
* _cpu_config==2 => Phi

* CONFIG=2 (phi board)
* UART  = 0x080a000c
* TIMER = 0x080a0014
* MHZ   = address to 64L

* Abel board
* UART  = 0xc000
* TIMER = 0x9000
* MHZ   = 0x8800

* Software board
* UART  = 0x80000024
* TIMER = 0x80000100
* MHZ   = 0x80000200

* TIMER[0] = 2 == latch
* TIMER[0] = low  long
* TIMER[1] = high long


 * UART[0] & 0x100 == 0 si busy (carractere a lire ?)
 * UART[0] = C ecriture
 * UART[1] = carractere lue | 0x100

  IFEQ  CYCLE_TIMER
timer_latch_phi
* phi expects running at 64Mhz, so multiply our microsecond timer by 64
   LDB   B3,U
   CMPB  #$14        ; phi ?
   BNE   timer_latch_phi3
   LDB   #6
timer_latch_phi2
   LSL   sampledTMR+7
   ROL   sampledTMR+6
   ROL   sampledTMR+5
   ROL   sampledTMR+4
   ROL   sampledTMR+3
   ROL   sampledTMR+2
   ROL   sampledTMR+1
   ROL   sampledTMR
   DECB
   BNE   timer_latch_phi2
timer_latch_phi3
   JMP   opSTOREIO_end
  ENDC

timer_high
   LDX   sampledTMR     ; load high word of latched timer
   LDD   sampledTMR+2
   BRA   opLOADIO_end
timer_low
   LDX   sampledTMR+4   ; load low word of latched timer
   LDD   sampledTMR+6
   BRA   opLOADIO_end
timer_mhz
   LDX   #0             ; return Mhz (1 for Thomson rtc)
   IFNE  CYCLE_TIMER
   LDD   #64
   ELSE
   LDD   #1
   ENDC
   BRA   opLOADIO_end

uart_read
   LDA   #1          ; read keyoard
   JSR   GETC
   TSTB
   BNE   opLOADIO_end
   CLRA
   BRA   opLOADIO_end
uart_write
   LDB   B7,U        ; prints a character
   JSR   PUTC
  IFNE  LPR
   IFEQ  TRACE
   JSR   RSCO
   ENDC
  ENDC
   BRA   opSTOREIO_end

timer_latch
   LDB   B7,U
   BITB  #2
   BEQ   opSTOREIO_end
   PSHS  U,CC        ; latches the current timer value
   ORCC  #$50
   LDU   #TIMER_CTR
   PULU  D,X
   STD   sampledTMR
   STX   sampledTMR+2
   PULU  D,X
   STD   sampledTMR+4
   STX   sampledTMR+6
   PULS  U,CC
  IFEQ  CYCLE_TIMER
   BRA   timer_latch_phi
  ELSE
   BRA   opSTOREIO_end
  ENDC

opLOADIO
   LDX   #0
   BU LDD,2
* phi board
   CMPD  #$000C
   BEQ   uart_rdy
   CMPD  #$0010
   BEQ   uart_read
   CMPD  #$0014
   BEQ   timer_low
   CMPD  #$0018
   BEQ   timer_high
* soft board
   CMPD  #$0024
   BEQ   uart_rdy
   CMPD  #$0028
   BEQ   uart_read
   CMPD  #$0100
   BEQ   timer_low
   CMPD  #$0104
   BEQ   timer_high
   CMPD  #$0200
   BEQ   timer_mhz
* default
uart_rdy
   LDD   #256        ; tell uart is rady to send
opLOADIO_end
   BU STX,0
   BU STD,2
   JMP   <fetch

opSTOREIO
   BU LDD,2
* phi board
   CMPD  #$000C
   BEQ   uart_write
   CMPD  #$0014
   BEQ   timer_latch
* soft board
   CMPD  #$0024
   BEQ   uart_write
   CMPD  #$0100
   BEQ   timer_latch
opSTOREIO_end
   LEAU  8,U         ; fixup stack
   JMP   <fetch

opLOAD SET *
  IFEQ B0-0
   LDA   ,U
   CMPA  #STK_SPACE/256
   BMI   opLOADnorm
   BHI   opLOADIO    ; yes => io-specific
   LDX   2,U
   BRA   opLOAD2
opLOADnorm SET *
   JSR   <getAddrMapped   ; convert adress
opLOAD2
   LDD   ,X          ; load high word
   STD   ,U          ; store in TOS
   LDD   2,X         ; load lower word
   STD   2,U         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction
  ELSE
   LDA   2,0          ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   opLOADnorm
   BHI   opLOADIO    ; yes => io-specific
opLOADstk
   JSR   <getAddrL   ; load from stack
   LDD   ,X          ; load high/low word
   STD   ,U          ; store in TOS
   LDD   2,X         ; load low/high word
   STD   2,U         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction
opLOADnorm SET *
   JSR   <getAddrL   ; convert adress
   LDD   ,X          ; load high word
   STD   2,U         ; store in TOS
   LDD   2,X         ; load lower word
   STD   ,U          ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction
  ENDC

opSTORE
  IFEQ B0-0
   LDA   ,U
   CMPA  #STK_SPACE/256
   BMI   opSTOREnorm
   BHI   opSTOREIO    ; yes => io-specific
   LDX   2,U
   BRA   opSTORE2
opSTOREnorm SET *
   JSR   <getAddrMapped   ; convert adress
opSTORE2
   LDD   B4,U
   STD   ,X
   LDD   B6,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back
  ELSE
   LDA   B2,U        ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   opSTOREnorm
   BHI   opSTOREIO   ; yes => io-specific code
opSTOREstk
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   4,U
   STD   ,X
   LDD   6,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back
opSTOREnorm SET *
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   B4,U
   STD   ,X
   LDD   B6,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back
  ENDC

opPOPSP
   BU LDU,2
   NEXT

getAddrStk
   IFNE B0-0
   BU LDA,0          ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   getAddrStk2
   LDA   B3,U
   EORA  #2
   STA   B3,U
getAddrStk2
   ENDC
   JMP   <getAddr

opLOADH
   BSR   getAddrStk  ; loads 16 bits
   LDD   ,X
   BRA   outUnsigned

opSTOREH
   BSR   getAddrStk  ; stores 16 bits
   LDD   B6,U
   STD   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

opLOADB
   BSR   getAddrStk  ; loads 8 bits
   CLRA
   LDB   ,X
outUnsigned
   BU STD,2
   LDD   #0
   BU STD,0
   JMP   <updatePC

opSTOREB
   BSR   getAddrStk  ; stores 8 bits
   LDB   B7,U
   STB   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

***************************************
* COMPARISON
***************************************

opLESSTHAN
   PULU  D,X
  IFEQ B0-0
   SUBD  ,U
  ELSE
   CMPX  2,U
  ENDC
   BLT   outTRUE
   BGT   outFALSE
  IFEQ B0-0
   CMPX  2,U
  ELSE
   SUBD  ,U
  ENDC
   BLO   outTRUE
   BRA   outFALSE

opLESSTHANOREQUAL
   PULU  D,X
  IFEQ B0-0
   SUBD  ,U
  ELSE
   CMPX  2,U
  ENDC
   BLT   outTRUE
   BGT   outFALSE
  IFEQ B0-0
   CMPX  2,U
  ELSE
   SUBD  ,U
  ENDC
   BLS   outTRUE
   BRA   outFALSE

opULESSTHAN
   PULU  D,X
  IFEQ B0-0
   SUBD  ,U
  ELSE
   CMPX  2,U
  ENDC
   BLO   outTRUE
   BHI   outFALSE
  IFEQ B0-0
   CMPX  2,U
  ELSE
   SUBD  ,U
  ENDC
   BLO   outTRUE
outFALSE
   LDD   #0          ; writes 0 on top of stack
outFALSE_D0
   STD   ,U
   STD   2,U
   NEXT

opULESSTHANOREQUAL
   PULU  D,X
  IFEQ B0-0
   SUBD  ,U
  ELSE
   CMPX  2,U
  ENDC
   BHI   outFALSE
   BLO   outTRUE
  IFEQ B0-0
   CMPX  2,U
  ELSE
   SUBD  ,U
  ENDC
   BHI   outFALSE
outTRUE
   LDD   #0          ; write 1 on top of stack
   BU STD,0
   INCB
   BU STD,2
   NEXT

opEQ
   PULU D,X
   CMPX  2,U
   BNE   outFALSE
   SUBD  ,U
   BNE   outFALSE
outTRUE_D0
   BU STD,0
   INCB
   BU STD,2
   NEXT

opNEQ
   PULU D,X
   SUBD  ,U
   BNE   outTRUE
   CMPX  2,U
   BNE   outTRUE_D0
   BRA   outFALSE_D0

***************************************
* SHIFT
***************************************

LSHIFTRIGHT MACRO
   LSRD
   BU ROR,2
   BU ROR,3
   ENDM

opLSHIFTRIGHT
   LEAU  4,U
   BU LDD,0
   BEQ   opLSHIFTRIGHT_
   BU LSR,3-4
   BCC   opLSHIFTRIGHT2
   LSHIFTRIGHT
opLSHIFTRIGHT2
   BU LSR,3-4
   BCC   opLSHIFTRIGHT4
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT4
   BU LSR,3-4
   BCC   opLSHIFTRIGHT8
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT8
   BU STD,0
   BU LSR,3-4
   BCC   opLSHIFTRIGHT16
*   abcd --> 0abc  swapped  cdab --> bc0a
  IFEQ B0-0
   LDD   1,U
   STD   2,U
   CLRA
   LDB   ,U
   STD   ,U
  ELSE
   LDA   3,U
   LDB   ,U
   STD   ,U
   CLRA
   LDB   2,U
   STD   2,U
  ENDC
opLSHIFTRIGHT16
   BU LSR,3-4
   BCC   opLSHIFTRIGHT32
*  abcd --> 00ab  swapped cdab --> ab00
   BU LDD,0
   BU STD,2
   LDD   #0
   BU STD,0
opLSHIFTRIGHT32
   JMP   <fetch

opLSHIFTRIGHT_
   BU LDD,2
   BU LSR,3-4
   BCC   opLSHIFTRIGHT_2
   LSRD
opLSHIFTRIGHT_2
   BU LSR,3-4
   BCC   opLSHIFTRIGHT_4
   LSRD
   LSRD
opLSHIFTRIGHT_4
   BU LSR,3-4
   BCC   opLSHIFTRIGHT_8
   LSRD
   LSRD
   LSRD
   LSRD
opLSHIFTRIGHT_8
   BU LSR,3-4
   BCC   opLSHIFTRIGHT_16
   TFR   A,B
   CLRA
opLSHIFTRIGHT_16
   BU LSR,3-4
   BCC   opLSHIFTRIGHT_32
   LDD   #0
opLSHIFTRIGHT_32
   BU STD,2
   JMP   <fetch

ASHIFTLEFT MACRO
   LSLD
   BU ROL,1
   BU ROL,0
   ENDM

opASHIFTLEFT
   LEAU  4,U
   BU LDD,2
   BEQ   opASHIFTLEFT_
   BU LSR,3-4
   BCC   opASHIFTLEFT2
   ASHIFTLEFT
opASHIFTLEFT2
   BU LSR,3-4
   BCC   opASHIFTLEFT4
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT4
   BU LSR,3-4
   BCC   opASHIFTLEFT8
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT8
   BU STD,2
   BU LSR,3-4
   BCC   opASHIFTLEFT16
* abcd --> bcd0 swapped cdab --> d0bc
  IFEQ B0-0
   LDD   1,U
   STD   ,U
   LDA   3,U
   CLRB
   STD   2,U
  ELSE
   LDA   3,U
   LDB   ,U
   STD   2,U
   LDA   1,U
   CLRB
   STD   ,U
  ENDC
opASHIFTLEFT16
   BU LSR,3-4
   BCC   opASHIFTLEFT32
* abcd --> cd00 swapped cdab --> 00cd
   BU LDD,2
   BU STD,0
   LDD   #0
   BU STD,2
opASHIFTLEFT32
   JMP   <fetch

opASHIFTLEFT_
   BU LDD,0
   BCC   opASHIFTLEFT_2
   BU LSR,3-4
   LSLD
opASHIFTLEFT_2
   BU LSR,3-4
   BCC   opASHIFTLEFT_4
   LSLD
   LSLD
opASHIFTLEFT_4
   BU LSR,3-4
   BCC   opASHIFTLEFT_8
   LSLD
   LSLD
   LSLD
   LSLD
opASHIFTLEFT_8
   BU LSR,3-4
   BCC   opASHIFTLEFT_16
   TFR   B,A
   CLRB
opASHIFTLEFT_16
   BU LSR,3-4
   BCC   opASHIFTLEFT_32
   LDD   #0
opASHIFTLEFT_32
   BU STD,0
   JMP   <fetch

ASHIFTRIGHT MACRO
   ASRD
   BU ROR,2
   BU ROR,3
   ENDM

opASHIFTRIGHT
   LEAU  4,U
   BU LDD,0
   BU LSR,3-4
   BCC   opASHIFTRIGHT2
   ASHIFTRIGHT
opASHIFTRIGHT2
   BU LSR,3-4
   BCC   opASHIFTRIGHT4
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT4
   BU LSR,3-4
   BCC   opASHIFTRIGHT8
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT8
   BU STD,0
   BU LSR,3-4
   BCC   opASHIFTRIGHT16
* abcd --> xabc  swapped cdab --> bcxa
  IFEQ B0-0
   LDD   1,U
   STD   2,U
   LDB   ,U
   SEX
   STD   1,U
  ELSE
   LDA   3,U
   LDB   ,U
   STD   ,U
   LDB   2,U
   SEX
   STD   2,U
  ENDC
opASHIFTRIGHT16
   BU LSR,3-4
   BCC   opASHIFTRIGHT32
* abcd --> xxab swapped cdab --> abxx
   LDX   #0
   BU LDD,0
   BU STD,2
   BPL   opASHIFTRIGHT16x
   LDX   #-1
opASHIFTRIGHT16x
   BU STX,0
opASHIFTRIGHT32
   JMP   <fetch

***************************************
* CONTROL FLOW (PC RELATED)
***************************************

opEMULATE_x
   LSLB              ; B=1xxx xx00
   LSLB              ; B=xxxx x000
   BEQ   opASHIFTRIGHT32 ; fetch
   CLRA              ; D=0000 0000 xxxx x000
   LSLD              ; D=0000 000x xxxx 0000
   LSLD              ; D=0000 00xx xxx0 0000=x*32
  IFEQ B0-0
   TFR   D,X
   LDD   #0
  ELSE
   LDX   #0
  ENDC
   PSHU  D,X
   * BRA   opCALL

opCALL
   BU_LDD 1,2
   ANDB  #$C0        ; clear lower bit
   TFR   D,X         ; saves PC_PG

   BU LDD,2          ; fix lower bits
   ANDA  #$3F
   ADDA  #$A0
   EXG   Y,D         ; update PC_REG

   SUBA  #$A0        ; clear upper bits of old PC
   ADDA  <PC_PG+1    ; add page lower bits
   BU STD,2          ; store lower word of PC
   LDB   <PC_PG      ; load pages upper bits
   CLRA              ; PC is 24 bits
   BU STD,0          ; store upper word of PC

   STX   <PC_PG      ; update PC page
   JMP   <updatePC

doBRANCH
  IFEQ 0
   TFR   Y,D
   SUBD  #$A001
   ADDA  <PC_PG+1
   BU ADDD,2
   STA   <PC_PG+1
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ROLA              ; save carry in b0
   ADDA  #%01000000
   LSRA              ; get cary back
   ORA   #%10000000
   TFR   D,Y         ; update pc reg
*
   LDD   <PC_PG
   BU ADCA,1
   ANDB  #$C0        ; align 16k
   STD   <PC_PG      ; update high word of PC
   LEAU  8,U         ; fixup stack
   JMP   <updatePC_D ; update page etc
  ELSE
   PULU  D,X
   STD   ,U
   STX   2,U
   * BRA   opPOPPCREL
  ENDC

opPOPPCREL
   BSR   addPCREL
   * BRA   opPOPPC

opPOPPC
   BU LDD,2          ; lower word of PC
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ADDA  #$A0
   TFR   D,Y         ; update pc reg
   BU_LDD 1,2        ; load page field
   ANDB  #$C0        ; align 16k
   STD   <PC_PG      ; update high word of PC
   LEAU  4,U         ; fixup stack
   JMP   <updatePC_D ; update page etc

addPCREL
   TFR   Y,D
   SUBD  #$A001
   ADDA  <PC_PG+1
   BU ADDD,2
   BU STD,2
   BU LDB,1
   ADCB  <PC_PG
   CLRA              ; 24 bits
   BU STD,0
   RTS

opCALLPCREL
   BSR   addPCREL
   BRA   opCALL

opEQBRANCH
   LDD   B4,U
   BNE   noBRANCH
   LDD   B6,U
   BEQ   doBRANCH
   BRA   noBRANCH

opNEQBRANCH
   LDD   B6,U
   BNE   doBRANCH
   LDD   B4,U
   BNE   doBRANCH
noBRANCH
   LEAU  8,U
   NEXT

opPUSHPC
   CLRA               ; 24 bits
   LDB   <PC_PG
   TFR   D,X

   TFR   Y,D
   SUBA  #$A0
   ADDA  <PC_PG+1
   SUBD  #1
   BCC   opPUSHPC2
   LEAX  -1,X
opPUSHPC2
   PSHU  D,X
   JMP   <fetch

***************************************
* INSTRUCTION TABLE
***************************************
   FDB   opSTORESP_16         ; 64 %0100 0000
   FDB   opSTORESP_17         ; 65 %0100 0001
   FDB   opSTORESP_18         ; 66 %0100 0010
   FDB   opSTORESP_19         ; 67 %0100 0011
   FDB   opSTORESP_20         ; 68 %0100 0100
   FDB   opSTORESP_21         ; 69 %0100 0101
   FDB   opSTORESP_22         ; 70 %0100 0110
   FDB   opSTORESP_23         ; 71 %0100 0111
   FDB   opSTORESP_24         ; 72 %0100 1000
   FDB   opSTORESP_25         ; 73 %0100 1001
   FDB   opSTORESP_26         ; 74 %0100 1010
   FDB   opSTORESP_27         ; 75 %0100 1011
   FDB   opSTORESP_28         ; 76 %0100 1100
   FDB   opSTORESP_29         ; 77 %0100 1101
   FDB   opSTORESP_30         ; 78 %0100 1110
   FDB   opSTORESP_31         ; 79 %0100 1111
   FDB   opSTORESP_0          ; 80 %0101 0000
   FDB   opSTORESP_1          ; 81 %0101 0001
   FDB   opSTORESP_2          ; 82 %0101 0010
   FDB   opSTORESP_3          ; 83 %0101 0011
   FDB   opSTORESP_4          ; 84 %0101 0100
   FDB   opSTORESP_5          ; 85 %0101 0101
   FDB   opSTORESP_6          ; 86 %0101 0110
   FDB   opSTORESP_7          ; 87 %0101 0111
   FDB   opSTORESP_8          ; 88 %0101 1000
   FDB   opSTORESP_9          ; 89 %0101 1001
   FDB   opSTORESP_10         ; 90 %0101 1010
   FDB   opSTORESP_11         ; 91 %0101 1011
   FDB   opSTORESP_12         ; 92 %0101 1100
   FDB   opSTORESP_13         ; 93 %0101 1101
   FDB   opSTORESP_14         ; 94 %0101 1110
   FDB   opSTORESP_15         ; 95 %0101 1111

   FDB   opLOADSP_16          ; 96 %0110 0000
   FDB   opLOADSP_17          ; 97 %0110 0001
   FDB   opLOADSP_18          ; 98 %0110 0010
   FDB   opLOADSP_19          ; 99 %0110 0011
   FDB   opLOADSP_20          ;100 %0110 0100
   FDB   opLOADSP_21          ;101 %0110 0101
   FDB   opLOADSP_22          ;102 %0110 0110
   FDB   opLOADSP_23          ;103 %0110 0111
   FDB   opLOADSP_24          ;104 %0110 1000
   FDB   opLOADSP_25          ;105 %0110 1001
   FDB   opLOADSP_26          ;106 %0110 1010
   FDB   opLOADSP_27          ;107 %0110 1011
   FDB   opLOADSP_28          ;108 %0110 1100
   FDB   opLOADSP_29          ;109 %0110 1101
   FDB   opLOADSP_30          ;110 %0110 1110
   FDB   opLOADSP_31          ;111 %0110 1111
   FDB   opLOADSP_0           ;112 %0111 0000
   FDB   opLOADSP_1           ;113 %0111 0001
   FDB   opLOADSP_2           ;114 %0111 0010
   FDB   opLOADSP_3           ;115 %0111 0011
   FDB   opLOADSP_4           ;116 %0111 0100
   FDB   opLOADSP_5           ;117 %0111 0101
   FDB   opLOADSP_6           ;118 %0111 0110
   FDB   opLOADSP_7           ;119 %0111 0111
   FDB   opLOADSP_8           ;120 %0111 1000
   FDB   opLOADSP_9           ;121 %0111 1001
   FDB   opLOADSP_10          ;122 %0111 1010
   FDB   opLOADSP_11          ;123 %0111 1011
   FDB   opLOADSP_12          ;124 %0111 1100
   FDB   opLOADSP_13          ;125 %0111 1101
   FDB   opLOADSP_14          ;126 %0111 1110
   FDB   opLOADSP_15          ;127 %0111 1111

opTable
   FDB   opBREAKPT            ;  0 %0000 0000
   FDB   opUNKNOWN            ;  1 %0000 0001
   FDB   opPUSHSP             ;  2 %0000 0010
   FDB   opUNKNOWN            ;  3 %0000 0011
   FDB   opPOPPC              ;  4 %0000 0100
   FDB   opADD                ;  5 %0000 0101
   FDB   opAND                ;  6 %0000 0110
   FDB   opOR                 ;  7 %0000 0111
   FDB   opLOAD               ;  8 %0000 1000
   FDB   opNOT                ;  9 %0000 1001
   FDB   opFLIP               ; 10 %0000 1010
   FDB   opNOP                ; 11 %0000 1011
   FDB   opSTORE              ; 12 %0000 1100
   FDB   opPOPSP              ; 13 %0000 1101
   FDB   opUNKNOWN            ; 14 %0000 1110
   FDB   opUNKNOWN            ; 15 %0000 1111

   FDB   opADDSP_0            ; 16 %0001 0000
   FDB   opADDSP_1            ; 17 %0001 0001
   FDB   opADDSP_2            ; 18 %0001 0010
   FDB   opADDSP_3            ; 19 %0001 0011
   FDB   opADDSP_4            ; 20 %0001 0100
   FDB   opADDSP_5            ; 21 %0001 0101
   FDB   opADDSP_6            ; 22 %0001 0110
   FDB   opADDSP_7            ; 23 %0001 0111
   FDB   opADDSP_8            ; 24 %0001 1000
   FDB   opADDSP_9            ; 25 %0001 1001
   FDB   opADDSP_10           ; 26 %0001 1010
   FDB   opADDSP_11           ; 27 %0001 1011
   FDB   opADDSP_12           ; 28 %0001 1100
   FDB   opADDSP_13           ; 29 %0001 1101
   FDB   opADDSP_14           ; 30 %0001 1110
   FDB   opADDSP_15           ; 31 %0001 1111

   FDB   opEMULATE_x          ; 32 %0010 0000
   FDB   opUNKNOWN            ; 33 %0010 0001
   FDB   opLOADH              ; 34 %0010 0010
   FDB   opSTOREH             ; 35 %0010 0011
   FDB   opLESSTHAN           ; 36 %0010 0100
   FDB   opLESSTHANOREQUAL    ; 37 %0010 0101
   FDB   opULESSTHAN          ; 38 %0010 0110
   FDB   opULESSTHANOREQUAL   ; 39 %0010 0111
   FDB   opSWAP               ; 40 %0010 1000
   FDB   opMULT               ; 41 %0010 1001
   FDB   opLSHIFTRIGHT        ; 42 %0010 1010
   FDB   opASHIFTLEFT         ; 43 %0010 1011
   FDB   opASHIFTRIGHT        ; 44 %0010 1100
   FDB   opCALL               ; 45 %0010 1101
   FDB   opEQ                 ; 46 %0010 1110
   FDB   opNEQ                ; 47 %0010 1111

   FDB   opNEG                ; 48 %0011 0000
   FDB   opSUB                ; 49 %0011 0001
   FDB   opXOR                ; 50 %0011 0010
   FDB   opLOADB              ; 52 %0011 0011
   FDB   opSTOREB             ; 52 %0011 0100
   FDB   opDIV                ; 53 %0011 0101
   FDB   opMOD                ; 54 %0011 0110
   FDB   opEQBRANCH           ; 55 %0011 0111
   FDB   opNEQBRANCH          ; 56 %0011 1000
   FDB   opPOPPCREL           ; 57 %0011 1001
   FDB   opEMULATE_x          ; 58 %0011 1010 opCONFIG
   FDB   opPUSHPC             ; 59 %0011 1011
   FDB   opEMULATE_x          ; 60 %0011 1100 opSYSCALL
   FDB   opPUSHSPADD          ; 61 %0011 1101
   FDB   opMULT16X16          ; 62 %0011 1110
   FDB   opCALLPCREL          ; 63 %0011 1111
(info)

***************************************
* MONITOR and TRACING
***************************************

OPCDE MACRO
   FCC   \0
   FCB   \1+0
   ENDM

   IFNE  TRACE
doTRACE
   PSHS  CC,DP,D,X,Y,U
   LEAX  ,U
   LDU   #traceFmt
doTRACE1
   LDB   ,U+
   BEQ   endTRACE
   CMPB  #'%
   BNE   doTRACE2
   BSR   doTRACE3
   BRA   doTRACE1
doTRACE2
   JSR   PUTCHAR
   BRA   doTRACE1
endTRACE
   PULS  CC,DP,D,X,Y,U,PC

doTRACE3
   LDB   ,U+            ; decodes %thing
   CMPB  #'s
   BEQ   printSTACK
   CMPB  #'p
   BEQ   printPC
   CMPB  #'o
   BEQ   printOP
   CMPB  #'a
   BEQ   printASM
   CMPB  #'u
   BEQ   printSP
   RTS

printSP
   PSHS  X              ; prints 16bit stack ptr
   LEAX  12,S
   JSR   HEX16
   PULS  X,PC

printOP
   LDB   ,y             ; prints 8bit op-code
   JMP   HEX

printPC
   PSHS  D,X            ; prints 24bit PC reg
   TFR   Y,D
   SUBA  #$A0
   ORA   <PC_PG+1
   PSHS  D
   CLRA
   LDB   <PC_PG
   PSHS  D
   LEAX  1,S
   JSR   HEX8
   JSR   HEX16
   LEAS  ,X
   PULS  D,X,PC

printSTACK
   CMPX  #$A000
  IFEQ B0-0
   LBLO  HEX32
  ELSE
   BLO   HEX32swap
  ENDC
   JSR   PUTSTR
   COLOR 4
   IFNE  LPR
   FCC   /-------/
   FCB   128+'-
   ELSE
   FCC   /--------/
   ENDC
   COLOR 128+COLOR_STACK
   RTS

  IFNE B0-0
HEX32swap
   LEAX  2,X
   JSR   HEX16
   LEAX  -4,X
   JSR   HEX16
   LEAX  2,X
   RTS
  ENDC

printASM
   PSHS  X,U
   LDU   #asmTbl           ; find the #B th entry in table
   LDB   ,Y
   BPL   srchMNEMO

   JSR   PUTSTR            ; IM d
   FCC   /IM/
   FCB   128+32
   LSLB
   ASRB
   BRA   noXOR

srchMNEMO
   LDA   #32
   INCB
srchLOOP
   CMPA  ,U
   BHI   skipMNEMO
   LEAX  ,U+
skipMNEMO
   CMPA  ,U+
   BLS   skipMNEMO
   DECB
   BNE   srchLOOP
   LDB   ,X+
printOPCDE
   JSR   PUTCHAR
   LDB   ,X+
   CMPB  #32
   BHS   printOPCDE
   TSTB
   BEQ   noDECIMAL
   ANDB  ,y
printDECIMAL
   LDA   #%01000000
   ANDA  ,y
   BEQ   noXOR
   EORB  #$10
noXOR
   JSR   DECIMAL
noDECIMAL
   PULS  X,U,PC

COLOR_ST    SET   2
COLOR_PC    SET   3
COLOR_OP    SET   6
COLOR_INST  SET   5
COLOR_STACK  SET  4


traceFmt
  IFEQ  LPR
* nice colorful trace
   * IFEQ  LPR
   * FCB   10,10,11,11
   * ENDC
   COLOR COLOR_STACK
   FCC   /%s %s %s %s/
   FCB   13,10
   COLOR COLOR_ST
   FCC   /%u /
   COLOR COLOR_PC
   FCC   /%p /
   COLOR COLOR_OP
   FCC   /%o /
   COLOR COLOR_INST
   FCC   /%a/
   COLOR COLOR_STACK
   FCB   13,10,0
  ELSE
* compatible with zpu.c
   FCC   /0x0%p 0x%o 0x%u/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   fcc   / %a/
   FCB   10,0
  ENDC

asmTbl
   OPCDE /BREAKPT/            ; 0
   OPCDE /???/                ; 1
   OPCDE /PUSHSP/             ; 2
   OPCDE /???/                ; 3
   OPCDE /POPPC/              ; 4
   OPCDE /ADD/                ; 5
   OPCDE /AND/                ; 6
   OPCDE /OR/                 ; 7
   OPCDE /LOAD/               ; 8
   OPCDE /NOT/                ; 9
   OPCDE /FLIP/               ; 10
   OPCDE /NOP/                ; 11
   OPCDE /STORE/              ; 12
   OPCDE /POPSP/              ; 13
   OPCDE /???/                ; 14
   OPCDE /???/                ; 15
   OPCDE /ADDSP/,32           ; 16..31
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   OPCDE /EMULATE/,32         ; 32
   FCB   31
   OPCDE /???/                ; 33
   OPCDE /LOADH/              ; 34
   OPCDE /STOREH/             ; 35
   OPCDE /LESSTHAN/           ; 36
   OPCDE /LESSTHANOREQUAL/    ; 37
   OPCDE /ULESSTHAN/          ; 38
   OPCDE /ULESSTHANOREQUAL/   ; 39
   OPCDE /SWAP/               ; 40
   OPCDE /MULT/               ; 41
   OPCDE /LSHIFTRIGHT/        ; 42
   OPCDE /ASHIFTLEFT/         ; 43
   OPCDE /ASHIFTRIGHT/        ; 44
   OPCDE /CALL/               ; 45
   OPCDE /EQ/                 ; 46
   OPCDE /NEQ/                ; 47
   OPCDE /NEG/                ; 48
   OPCDE /SUB/                ; 49
   OPCDE /XOR/                ; 50
   OPCDE /LOADB/              ; 51
   OPCDE /STOREB/             ; 52
   OPCDE /DIV/                ; 53
   OPCDE /MOD/                ; 54
   OPCDE /EQBRANCH/           ; 55
   OPCDE /NEQBRANCH/          ; 56
   OPCDE /POPPCREL/           ; 57
   OPCDE /CONFIG/             ; 58
   OPCDE /PUSHPC/             ; 59
   OPCDE /SYSCALL/            ; 60
   OPCDE /PUSHSPADD/          ; 61
   OPCDE /MULT16X16/          ; 62
   OPCDE /CALLPCREL/          ; 63
   OPCDE /STORESP/,32         ; 64..95
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   OPCDE /LOADSP/,32         ; 96..127
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31

(info)
   ENDC

FILENAME
   FCC   /0:/
   * FCC   /dhr13k  /
   FCC   /dhryston/
   * FCC   /test    /
   * FCC   /test2   /
   * FCC   /a       /
   * FCC   /eliza   /
   FCC   /bin/
   FCB   0

FAT
   RMB   256
BUF
   RMB   256

***************************************
* Hello world example
***************************************
   * ORG   $A000

* INCDAT dhryston.bin

   IFNE  0
* https://github.com/tobyjaffey/libzpu/blob/master/zpusim-mini/zpusim-mini.c
   FCB   $80,$3d,$0d,$f8,$80,$80,$82
   FCB   $80,$51,$80,$c8,$71,$0c,$80
   FCB   $e5,$71,$0c,$80,$ec,$71,$0c
   FCB   $80,$ec,$71,$0c,$80,$ef,$71
   FCB   $0c,$a0,$71,$0c,$80,$d7,$71
   FCB   $0c,$80,$ef,$71,$0c,$80,$f2
   FCB   $71,$0c,$80,$ec,$71,$0c,$80
   FCB   $e4,$71,$0c,$8d,$71,$0c,$8a
   FCB   $71,$0c,$00,$82,$3d,$0d,$04
   ENDC
HEAP

   END   main
