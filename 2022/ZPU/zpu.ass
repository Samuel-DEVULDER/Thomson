(main)zpu
   ORG   $7000

FIRST_PAGE  SET   2           ; address 0 is mapped to that page
SAFE        SET   0           ; force long addressing for long ops (slower)
TRACE       SET   0           ; traces executed instructions
LPR         SET   0           ; also output result to printer on parallel port
CYCLE_TIMER SET   0           ; timer based on cycle (costly) or rtc (accurate) ?
STACK_SIZE  SET   2048        ; size of stack
IO_SPACE    SET   $0800       ; address above IO_SPACE:00000 are IO related (value chosen for Phi board)
STK_SPACE   SET   IO_SPACE-1  ; high word of unmapped zone (make sure it is below IO_SPACE)
TEO_BUGFX   SET   1           : fxes SBCA/B setting V flag where it sould'nt

***************************************
* System equates
***************************************
PUTC  EQU   $E803             ; prints a char
GETC  EQU   $E806             ; reads the keybord
RSOPC EQU   $602B             ; serial/parallel command
RSCO  EQU   $E812             ; serial/parallel execute
LGA5  EQU   $E7E5             ; reg for memory bank at $A000-$DFFF
LGA6  EQU   $E7E6             ; reg for memory bank at $0000-$3FFF
LGA7  EQU   $E7E7             ; Gate Array "mode page"

COLOR MACRO
   IFEQ  LPR
   FCB   27,$40+\0
   ENDC
   ENDM

ASRD  MACRO
   ASRA
   RORB
   ENDM

LSRD  MACRO
   LSRA
   RORB
   ENDM

LSLD  MACRO
   LSLB
   ROLA
   ENDM

main
   LEAS  main,PCR

   LDD   #PAGE0+$1000
   TFR   B,DP
   SETDP PAGE0

   ORA   >$6081      ; Activate
   STA   >$6081      ; direct
   STA   >LGA7       ; RAM

   LDA   >$E000      ; $E00 sentinel
   STA   <romSentinel+1
   BGE   okSentinel
   JSR   PUTSTR
   FCC   /ERROR $E000</
   FCB   128+'0
   SWI
   BRA   *
okSentinel

   BSR   INITLPR
   BSR   INITMEMORY

   LDX   #FILENAME
   JSR   LOADFILE

   JSR   INITTIMER

GOZPU
   LDU   #$A000-8    ; set stack ptr
   STU   <page       ; force page to be out of address space
   LDD   #0
   LDX   #$0000
   PSHU  D,X         ; push address $0000 0000
   JMP   opPOPPC     ; and off we go

INITLPR
   IFNE  LPR         ; open parallel port
   LDB   #$40
   STB   >RSOPC
   JSR   >RSCO
   LDB   #$08        ; to write bytes
   STB   >RSOPC
   LDB   #12
   JMP   >RSCO
   ELSE
   RTS
   ENDC

***************************************
* MEMORY
***************************************
LAST_PAGE
   FCB   0

INITMEMORY
   BSR   FINDMAX        ; guess LAST_PAGE
   BSR   PRINTMAX       ; prints a message about it
   LDX   #$A000
   LDA   LAST_PAGE      ; clear all banks starting from the last one
CLRPAGES
   STA   LGA5           ; update bank
   CMPA  #FIRST_PAGE    ; first page ?
   BEQ   CLRHEAP        ; yes => only clear HEAP data
   BSR   CLRMEM         ; no => clear $A000..$DFFF
   DECA                 ; next page
   BRA   CLRPAGES
CLRHEAP
   LDX   #FAT
   * BRA   CLRMEM

CLRMEM
   PSHS  D,X         ; clears a memory zone upto $E000
   LDD   #0
   BRA   CLRMEM2
CLRMEM1
   STD   ,X
   STD   2,X
   STD   4,X
   STD   6,X
   STD   8,X
   STD   10,X
   STD   12,X
   STD   14,X
   LEAX  16,X
CLRMEM2
   CMPX  #$E000-16
   BLS   CLRMEM1
   BRA   CLRMEM4
CLRMEM3
   STB   ,X+
CLRMEM4
   CMPX  #$E000
   BLO   CLRMEM3
   PULS  D,X,PC
FINDMAX
   PSHS  D,X            ; find maximum page (LAST_PAGE)
   LDX   #$A000
   LDD   #FIRST_PAGE-1
FINDMAX1
   INCB
   CMPB  #$20
   BEQ   FINDMAX3
   STB   LGA5
   STB   ,X
FINDMAX2
   BSR   CHKSIG         ; check sucessfull writing of 256 random values at X
   BNE   FINDMAX3       ; if one fails cut scan here
   DECA                 ; decrement
   BNE   FINDMAX2       ; 256 success ? no=>loop
   BRA   FINDMAX1       ; yes => valid bank, try next one
FINDMAX3
   DECB
   STB   LAST_PAGE
   PULS  D,X,PC

CHKSIG
   PSHS  D           ; suffle bits (multiply by 5)
   LDA   ,X
   LDB   #5
   MUL
   STB   ,X
   LDB   1,X
   LDA   #5
   MUL
   ORB   #1
   ADDA  ,X
   STD   ,X
   SUBD  ,X          ; $5FFE is mapped on $DFFE when we wrapped around the number of pages
   PULS  D,PC

PRINTMAX
   PSHS  D
   JSR   PUTSTR
   FCB   12
   FCC   /Found/
   FCB   128+32
   LDB   LAST_PAGE
   SUBB  #FIRST_PAGE-1
   JSR   DECIMAL
   JSR   PUTSTR
   FCC   /x16k free memory/
   FCB   13,10+128
   PULS  D,PC

PUTS
   PSHS  B        ; prints a 0 or neg-terminated string pointed by X (updated)
   BRA   PUTS1
PUTS0
   BSR   PUTCHAR
PUTS1
   LDB   ,X+
   BEQ   PUTS2
   BPL   PUTS0
   ANDB  #127
   BSR   PUTCHAR
PUTS2
   PULS  B,PC

PUTSTR
   PSHS  X           ; prints the string follwing the call
   LDX   2,S
   BSR   PUTS
   STX   2,S
   PULS  X,PC

HEX32
   BSR   HEX16       ; prints 32 bits value at X (incremented)
HEX16
   BSR   HEX8        ; prints 16 bits value at X (incremented)
HEX8
   LDB   ,X+         ; prints 8 bits value at X (incremented)
   * BRA   HEX
HEX
   BSR   HEX0        ; print B in hexa (A trashed)
   EXG   A,B
HEX0
   LDA   #$10
   MUL
   ADDA  #$90
   DAA
   ADCA  #$40
   DAA
   EXG   A,B
PUTCHAR
   IFNE  LPR
   IFEQ  TRACE
   JSR   PUTC
   ENDC
   JMP   RSCO
   ELSE
   JMP   PUTC              ; prints a character (in B)
   ENDC

DECIMAL
   STB   ,-S               ; prints a signed byte in decimal
   BPL   DECIMAL1
   NEG   ,S
   BSR   PUTSTR
   FCB   128+'-
DECIMAL1
   CLRA
   LDB   #8
DECIMAL2
   LSL   ,S
   STA   ,-S
   ADCA  ,S+
   DAA
   DECB
   BNE   DECIMAL2
   STA   ,S
   BCC   DECIMAL3
   BSR   PUTSTR
   FCB   128+'1
   LDB   ,S+
   BRA   HEX8
DECIMAL3
   LDB   ,S
   LSRB
   LSRB
   LSRB
   LSRB
   BEQ   DECIMAL4
   ADDB  #'0
   BSR   PUTCHAR
DECIMAL4
   LDB   ,S+
   ANDB  #15
   ADDB  #'0
   BRA   PUTCHAR

LOADFILE
   PSHS  A,X,U
   BSR   PUTSTR
   FCC   /Loading/
   FCB   32+128
   BSR   PRINTFN
   BSR   PUTSTR
   FCC   /../
   FCB   128+'.
   LDA   #FIRST_PAGE
   LDX   1,S
   LDU   #$A000
   BSR   LOAD
   BSR   PUTSTR
   FCC   /done/
   FCB   13,10,13,10+128
   PULS  A,X,U,PC
PRINTFN
   PSHS  D,X,U
   LDA   #8
   LDB   1,X
   CMPB  #':
   BNE   PRINTFN1
   ADDA  #2
PRINTFN1
   LEAU  A,X
PRINTFN2
   DECA
   BMI   PRINTFN3
   LDB   A,X
   CMPB  #32
   BEQ   PRINTFN2
   INCA
   BSR   PRINTFN4
PRINTFN3
   LEAX  ,U
   LDD   #3*256+'.
   JSR   PUTCHAR
   BSR   PRINTFN4
   PULS  D,X,U,PC
PRINTFN4
   LDB   ,X+
   JSR   PUTCHAR
   DECA
   BNE   PRINTFN4
   RTS

*--------------------------------------*|*
  * Module de chargement pour un fichier *
  * Entrees:                             *
  * A = BANK                             *
  * X = Pointeur sur nom de fichier      *
  * U = Adresse d'implantation           *
  *--------------------------------------*
*DKOPC equ    $6048  ; operation d7
DKDRV EQU   $6049    ; lecteur
DKTRK EQU   $604A    ; piste (2 ocets)
DKSEC EQU   $604C    ; secteur
DKSTA EQU   $604E    ; status d7
DKBUF EQU   $604F    ; buf i/o
DKCAT EQU   $60E9    ; ptr catalogue
DKNAM EQU   $60E7    ; nom fichier
DKTYP EQU   $60EB    ; type fichier (2octets)
DKFAT EQU   $60ED    ; ptr fat
DKMOD EQU   $60F0    ; mode d'acces
DKFIN EQU   $60F3    ; dernier bloc
DKBLK EQU   $60F6    ; 1er bloc fichier
DKTDS EQU   $60F7    ; nb octets dern sect (2octets)
DKIFA EQU   $60F9    ; secteur fat fichier
LECFA EQU   $E00D    ; lecture fat
RECFI EQU   $E010    ; recherche fichier
CONVB EQU   $E01F    ; converison bloc
DKCOM EQU   $E82A    ; commande d7
LOAD
   PSHS  D,X,U,DP    ; Load a file from minidos
   STA   LGA5        ; set bank
   PSHS  A           ; set BANK cpt
   SETDP $60
   LDD   #$6000
   TFR   A,DP
   STB   DKDRV
   LDA   1,X
   CMPA  #':
   BNE   LOAD00
   LDA   ,X++
   SUBA  #'0
   STA   DKDRV
LOAD00
   LDA   #$02     A=2, B=$00
   STB   DKSTA    Efface erreur
   STD   DKTYP    Type de fichier
   STX   DKNAM    Nom du fichier
   STU   LDPTR    Adr d'implantation
* Chargement de la FAT
   LDX   #BUF
   STX   DKCAT
   LDX   #FAT
   STX   DKFAT
   JSR   LECFA    Charge la FAT
   BCS   ERRIO    Si "I/O Error"
* Recherche du fichier
   LDA   #1       | Initialise
   STA   DKMOD    | en LOAD
   JSR   RECFI    Recherche fichier
   TST   DKIFA    | Si $60F9 = 0,
   BEQ   ERRNF    | fich non trouve'
* Convertit numero de bloc
LOAD0
   JSR   CONVB    Convertit bloc
   STB   DKTRK+1  Initialise piste
   LDX   DKFAT    Pointeur sur FAT
   LDB   DKBLK    Bloc courant
   INCB           | Bloc
   LDB   B,X      | suivant
   STB   DKBLK    Sauve le bloc
   CMPB  #$C0     | Si dernier bloc,
   BHI   LOAD1    | recupere taille
   LDB   #$08     8 secteurs a charg
LOAD1
   ANDB  #$0F     Isole taille bloc
   STA   DKSEC    Sauve premier bloc
   ADDB  DKSEC    Ajoute depart bloc
   DECB           Ajuste dern bloc
   STB   DKFIN    Sauve dernier bloc
* Charge les secteurs
LOAD2
   JSR   DKCOM    Charge le secteur
   BCS   ERRIO    Si "I/O Error"
   LDA   $604C    | Si secteur pas
   CMPA  DKFIN    | secteur maximum,
   BNE   LOAD3    | passe
   LDA   DKBLK    | Si dernier
   CMPA  #$C0     | secteur du
   BHI   LOAD4    | fichier, sort
   BSR   TFR      Transfere donnees
   BRA   LOAD0    Bloc suivant
LOAD3
   BSR   TFR      Transfere donnees
   INC   $604C    Secteur + 1
   BRA   LOAD2    Secteur suivant
* Chargement dernier secteur et sortie
LOAD4
   LDD   DKTDS    Taille dern sect
   BEQ   LOAD5    Si 0, sort
   BSR   TFR0     Transfere donnees
LOAD5
   CLRA           efface carry
LOAD6
   LDD   ,S+      ; fixe cpt BANK
   STB   LGA5     ; restore init BANK
   PULS  D,X,U,DP,PC
ERRIO
   JSR   PUTSTR
   FCB   13,10
   FCC   /IO ERROR/
   FCB   7+128
ERRLOOP
   BRA   ERRLOOP
ERRNF
   JSR   PUTSTR
   FCB   13,10
   FCC   /FILE NOT FOUND/
   FCB   7+128
   BRA   ERRLOOP
ERROM
   LEAS  2,S
   JSR   PUTSTR
   FCB   13,10
   FCC   /OUT OF MEMORY/
   FCB   7+128
   BRA   ERRLOOP
* Transfert des donnees
TFR
   LDB   $6058   | Ajuste taille
   COMB          | maximum du
   ORB   #$80    | secteur
TFR0
   LDX   #0      Recupere ptr mem
LDPTR SET   *-2
   LEAU  ,X
   ABX
   CMPX  #$E000
   LEAX  ,U
   LDU   DKBUF   Ptr buffer secteur
   BCC   TFRslow
TFRfast
   LDA   ,U+     |
   STA   ,X+     | Transfere
   DECB          | les donnees
   BNE   TFRfast |
TFR1
   STX   LDPTR   Sauve implantation
   RTS
TFRslow
   LDA   ,U+     |
   STA   ,X+     | Transfere
   CMPX  #$E000
   BEQ   TFRslow2
   DECB          | les donnees
   BNE   TFRslow |
   BRA   TFR1
TFRslow2
   LDX   #$A000
   LDA   3,S
   INCA
   CMPA  LAST_PAGE
   BHI   ERROM
   STA   3,S
   STA   LGA5
   DECB          | les donnees
   BNE   TFRfast
   BRA   TFR1

   SETDP 0

***************************************
* Timer
***************************************
TIMEPT   EQU   $6027
STATUS   EQU   $6019
KBIN     EQU   $E830

TIMER_CTR
   FDB   0        ; timer counter (64 bits)
   FDB   0
   FDB   0
   FDB   0

INITTIMER
   PSHS  D,X      ; init timer
   ORCC  #$50
   LDD   #0
   LDX   #0
   LDU   #TIMER_CTR+8
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
   PSHU  D,X
   IFEQ  CYCLE_TIMER
   LDX   #TIMERINTER
   STX   TIMEPT
   LDA   STATUS
   ORA   #%00100000
   STA   STATUS
   ENDC
   ANDCC #$FF-$50
   PULS  D,X,PC

* 100 ms = 100 000 us
*        = $1 86A0
   IFNE  CYCLE_TIMER
TINC2 SET 0
TINC1 SET 1
   ELSE
TINC2 SET $1
TINC1 SET $86A0
   ENDC
TIMERINTER
   IFNE  CYCLE_TIMER
   PSHS  D,X
   ENDC
   LDX   #TIMER_CTR+4
   LDD   #TINC1
   ADDD  2,X
   STD   2,X
   LDD   ,X
   ADCB  #TINC2
   ADCA  #0
   STD   ,X
   BCC   TIMERINTERX
   LDD   -2,X
   ADCB  #0
   ADCA  #0
   STD   -2,X
   BCC   TIMERINTERX
   LDD   -4,X
   ADCB  #0
   ADCA  #0
   STD   -4,X
TIMERINTERX
   IFNE  CYCLE_TIMER
   PULS  D,X,PC
   ELSE
   JMP   KBIN
   ENDC

   ORG   ((*+255)/256)*256
PAGE0   SET   */256
   SETDP PAGE0

FETCH_INSTRUCTION MACRO
   IFNE  TRACE
   JSR   doTRACE
   ENDC
   LDB   ,Y+         ; fetch next instruction code
   ENDM

* loads a 7 bit immediate value
* B=xxxxxxx0 (value*2)
opIM
   ASRB              ; left align signed value
   LDX   #0          ; [3] clear high word
   SEX               ; [2] extends sign to A ($00 or $FF)
   LEAX  A,X         ; [5] extends sign to X
   PSHU  D,X         ; [9] push lower word
   FETCH_INSTRUCTION
   BPL   chkPC       ; next is opIM ? no ==> process next
   * BRA   opIM_nxt        instruction (B already fetched)

* loads a continuated immediate value
* B=xxxxxxx0 (value*2)
opIM_nxt
   LSLB
   LSR   2,U          ; rotate TOS 7 bits left and add B/2 at the bottom
   LDA   3,U
   RORA
   STA   2,U          ; byte 0 is byte 1 rotated right once
   LDA   ,U
   RORA
   STA   3,U         ; byte 1 is byte 2 rotated right once
   LDA   1,U
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   STD   ,U          ; write lower word
   FETCH_INSTRUCTION
   BMI   opIM_nxt    ; opIM? yes => just increment PC
   BRA   chkPC       ; next instruction (B already fetched)

* SAFE version of getAddr for long values
getAddrL
   IFNE  SAFE
   LDB   #%11111100
   ANDB  3,U         ; just clear the 2 lower bits of TOS
   STB   3,U
   ENDC

* make page and X points to the address in TOS (stack unmodified)
getAddr
   LDA   2,U         ; speedup: if nul then adress is mapped
   BEQ   getAddrMapped
   LDX   ,U
   RTS
getAddrMapped
   LDD   ,U          ; load lower part of the address
   ANDA  #$3F        ; clear high bits
   ADDA  #$A0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X updated
   LDA   3,U
   LDB   ,U          ; load 16kb page section of address

* updates page when neeeded
* D=high bytes of the 24bits address
updatePage
   ANDB  #$C0        ; just keep the 2 top bits
   CMPD  #page       ; compare with current page index
page equ *-2         ; page index (dynamic code)
   BEQ   donePage    ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA
* map proper BANk onto $A000...$DFFF space
* A=BANk number
chgBANK
   ADDA  #FIRST_PAGE
   STA   LGA5        ; need to check, might use PIA instead
donePage
   RTS               ; done

* restore the page back to the instruction page
updatePC
   LDD  #PC_PG       ; load instruction page
PC_PG SET *-2        ; instruction page (dynamic code)
updatePC_D
   BSR  updatePage   ; update page if needed

* fetches and execute an instruction
fetch
opNOP
   FETCH_INSTRUCTION
chkPC
   IFNE  CYCLE_TIMER
   JSR   TIMERINTER
   ENDC
romSentinel
   CMPB  #$4D        ; speed up: if next byte is different
   BNE   decode      ; from the one on $E000 we are safe to decode
   CMPY  #$E000      ; check page change
   BLO   decode      ; no => just decode inwtruction
   PSHS  B           ; preserve opcode
   LDD   <PC_PG      ; load PC page
   ADDD  #$40        ; adds 16kb
   STD   <PC_PG      ; update PC page
   BSR   updatePage  ; update BANk
   LDY   #$A000      ; go to start of page
   PULS  B           ; restore opcode
decode
   LSLB              ; decode the opcode
   BCS   opIM        ; opcode=1xxxxxxx ? yes => immediate value
   BMI   opLDSTSP_x  ; opcode=01xxxxxx ? yes => LDsp_x or STsp_x
   LDX   #opTable
   JMP   [B,X]       ; jump to instruction

* COMmon part between opLD and opST depending on N flag
opLDSTSP_x
   EORB  #$20
   LSLB              ; B ~ x*4
   BPL   opSTORESP_x
*  BRA   opLOADSP_x

***************************************
* Load on stack the value at stack[x]
* B=-xxxxx00 (4*x)
***************************************
opLOADSP_x
   ANDB  #%01111100  ; clear bit 7 of 4*x
   LEAX  B,U         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHU  D,X         ; push 32 bits
   BRA   fetch       ; next instruction

sampledTMR
   FDB   0           ; sampled timer
   FDB   0
   FDB   0
   FDB   0

* Write top of stack at stack[x]
* B=0xxxxx00 (4*x)
opSTORESP_x
   LEAX  B,U         ; X point to dest (bit7 already 0)
   PULU  D           ; load low word
   STD   ,X          ; store low word
   PULU  D           ; load high word
   STD   2,X         ; store high word
   BRA   fetch       ; next instruction
   
* Adds to TOS the value at stack[x]
* B=0--xxxx00 (4*x)
opADDSP_x
   LSLB              ; B ~ 4*x
   ANDB  #%00111100  ; make 4*x postitive
   LEAX  B,U         ; X point to source
   LDD   ,X          ; load low word of source
   ADDD  ,U          ; add low word of TOS
   STD   ,U          ; store result to TOS (lower word)
   LDD   2,X         ; load high word of source<<
   ADCB  3,U         ; add with carry the TOS (high word)
   ADCA  2,U         ; second byte
   STD   2,U         ; store result to TOS (high word)
   BRA   fetch       ; next instruction

opUNKNOWN

opBREAKPT
   LDA   STATUS
   ANDA  #%11011111  ; disable timer interrupt
   STA   STATUS
   SWI               ; back to monitor

* Pushes stack address
opPUSHSP
   LDX   #STK_SPACE  ; stack address is $01FF:9xxx
   TFR   U,D
   PSHU  D,X
   BRA   fetch

opPUSHSPADD
   LDD   ,U
   LSLD
   LSLD
   LEAX  D,U
   STX   ,U
   LDD   #STK_SPACE  ; stack address is $01FF:9xxx
   STD   2,U         ; BANk 0, $Dxxx
   JMP   <fetch

***************************************
* ARITHMETIC
***************************************

opSUB
   LEAX  ,U
   JSR   neg_x

opADD
   PULU  D,X
   ADDD  ,U
   STD   ,U
   TFR   X,D
   ADCB  3,U
   ADCA  2,U
   STD   2,U
   JMP   <fetch      ; next intruction

opMULT
   LDD   #0          ; clear upper word
   STD   -4,U        ; 2301
   LDA   1,U         ; 6745
   LDB   5,U         ; compute byte #4
   MUL               ; 3+7
   STD   -2,U        
   LEAX  -3,U        ; compute byte #3
   LDD   #$0005      ; 2+7
   BSR   MULT1      
   LDD   #$0104      ; 3+6
   BSR   MULT1       
   LEAX  -4,U        ; compute byte #2
   LDD   #$0305      ; 1+7
   BSR   MULT2       
   LDD   #$0004      ; 2+6
   BSR   MULT2
   LDD   #$0107      ; 3+5
   BSR   MULT2
   LDD   #$0205      ; compute byte #1
   BSR   MULT3       ; 0+7
   LDD   #$0304
   BSR   MULT3       ; 1+6
   LDD   #$0007
   BSR   MULT3       ; 2+5
   LDD   #$0106
   BSR   MULT3       ; 3+4
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   2,U
   LDD   2,X
   STD   ,U
   JMP   <fetch
MULT1
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   BCC   MULT0
   INC   -1,X
MULT0
   RTS
MULT2
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDD  ,X
   STD   ,X
   RTS
MULT3
   LDA   A,U
   BEQ   MULT0
   LDB   B,U
   BEQ   MULT0
   MUL
   ADDB  ,X
   STB   ,X
   RTS

opMULT16X16
   LDD   #0          ; clear upper word
   STD   -4,U        ; 2301
   LDA   1,U         ; 6745
   LDB   5,U
   MUL               ; compute byte #4
   STD   -2,U        ; 3+7
   LEAX  -3,U
   LDD   #$0005      ; compute byte #3
   BSR   MULT1       ; 2+7
   LDD   #$0104      ; 3+6
   BSR   MULT1       
   LEAX  -4,U
   LDD   #$0004      ; compute byte #2
   BSR   MULT2       ; 2+6
   LEAU  4,U         ; copy result to TOS
   LDD   ,X
   STD   2,U
   LDD   2,X
   STD   ,U
   JMP   <fetch

opNEG
   LEAX  ,U
   BSR   neg_x
   JMP   <fetch
neg_x
   LDD   #0
   SUBD  ,X
   STD   ,X
   LDD   #0
   BCC   neg_x1
   LDD   #-1
neg_x1
   SUBD  2,X
   STD   2,X
   RTS

opDIV
   CLR   ,-S            ; clear sign bit
   LEAX  ,U
   LDB   2,X
   BPL   opDIV1
   COM   ,S             ; negate sign
   BSR   neg_x          ; negate dividend
opDIV1
   LEAX  4,U
   LDB   2,X
   BPL   opDIV2
   COM   ,S             ; negate sign
   BSR   neg_x          ; negate divisor
opDIV2
   BSR   UDIV32
   LEAX  4,U
   LDD   2,U
   COMA
   COMB
   STD   2,X
   LDD   ,U
   COMA
   COMB
opDIV4
   STD   ,X
   LEAU  ,X             ; fix stack
   LDB   ,S+            ; test sign
   BPL   opDIV3         ; positive => no chg
   BSR   neg_x          ; negate result
opDIV3
   JMP   <fetch

opMOD
   LEAX  ,U
   LDB   2,X
   STB   ,-S            ; store sign
   BPL   opMOD1
   BSR   neg_x          ; negate dividend
opMOD1
   LEAX  4,U
   LDB   2,X
   BPL   opMOD2
   BSR   neg_x          ; negate divisor
opMOD2
   BSR   UDIV32
   LEAX  4,U
   LDD   -4,U
   STD   2,X
   LDD   -2,U
   BRA   opDIV4

* https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder
UDIV32
   LDD   #0
   STD   -4,U           ; R=0
   STD   -2,U
   LDX   #32
UDIV32_1
   ROL   1,U            ; N = N<<1
   ROL   ,U
   ROL   3,U
   ROL   2,U            ; carry = N(i)
   LDD   -2,U
   ROLB                 ; inject N(i)
   ROLA
   STD   -2,U
   ROL   -3,U
   ROL   -4,U           ; R = {R<<1 | N(i)}
   SUBD  4,U            ; R-D (low)
   STD   -6,U           ; save temp
   LDD   -4,U
   SBCB  7,U
   SBCA  6,U            ; R-D (high)
   BCS   UDIV32_2       ; R-D<0 ? yes => no chg
   STD   -4,U           ; R = R-D (high)
   LDD   -6,U           ; retrieve temp
   STD   -2,U           ;     R-D (low)
UDIV32_2
   LEAX  -1,X
   BNE   UDIV32_1
   ROL   1,U            ; inject last comparison bit
   ROL   ,U
   ROL   3,U
   ROL   2,U
   RTS

***************************************
* LOGIC
***************************************

opAND
   PULU  D,X         ; bitwise "and" of TOS with NOS
   ANDA  ,U
   ANDB  1,U
   STD   ,U
   TFR   X,D
   ANDA  2,U
   ANDB  3,U
   STD   2,U
   JMP   <fetch

opOR
   PULU  D,X         ; bitwise "or" of TOS with NOS
   ORA   ,U
   ORB   1,U
   STD   ,U
   TFR   X,D
   ORA   2,U
   ORB   3,U
   STD   2,U
   JMP   <fetch

opXOR
   PULU  D,X         ; bitwise "xor" of TOS with NOS
   EORA  ,U
   EORB  1,U
   STD   ,U
   TFR   X,D
   EORA  2,U
   EORB  3,U
   STD   2,U
   JMP   <fetch

opNOT
   COM   ,U          ; bitwise complement of TOS
   COM   1,U
   COM   2,U
   COM   3,U
   JMP   <fetch

flip2
   LSRA              ; helper to flip A and B bits
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   ROLB
   RORA
   RTS

opFLIP
   LDA   ,U          ; flips the bits of the TOS
   LDB   3,U
   BSR   flip2       ; 1/2
   STA   ,U
   STB   3,U
   LDD   1,U         
   BSR   flip2       ; 0/3
   STD   1,U
   JMP   <fetch

opSWAP
   LDD   ,U
   LDX   2,U
   STX   ,U
   STD   2,U
   JMP   <fetch

***************************************
* MEMORY
***************************************

* https://github.com/zylin/zpu/blob/master/zpu/sw/startup/crt_io.c

* _cpu_config==0 => Abel
* _cpu_config==1 => Zeta
* _cpu_config==2 => Phi

* CONFIG=2 (phi board)
* UART  = 0x080a000c
* TIMER = 0x080a0014
* MHZ   = address to 64L

* Abel board
* UART  = 0xc000
* TIMER = 0x9000
* MHZ   = 0x8800

* Software board
* UART  = 0x80000024
* TIMER = 0x80000100
* MHZ   = 0x80000200

* TIMER[0] = 2 == latch
* TIMER[0] = low  long
* TIMER[1] = high long


 * UART[0] & 0x100 == 0 si busy (carractere a lire ?)
 * UART[0] = C ecriture
 * UART[1] = carractere lue | 0x100

   IFEQ  CYCLE_TIMER
timer_latch_phi
* phi expects running at 64Mhz, so multiply our microsecond timer by 64
   LDB   1,U
   CMPB  #$14        ; phi ?
   BNE   timer_latch_phi3
   LDB   #6
timer_latch_phi2
   LSL   sampledTMR+7
   ROL   sampledTMR+6
   ROL   sampledTMR+5
   ROL   sampledTMR+4
   ROL   sampledTMR+3
   ROL   sampledTMR+2
   ROL   sampledTMR+1
   ROL   sampledTMR
   DECB
   BNE   timer_latch_phi2
timer_latch_phi3
   JMP   opSTOREIO_end
   ENDC

timer_high
   LDX   sampledTMR     ; load high word of latched timer
   LDD   sampledTMR+2
   BRA   opLOADIO_end
timer_low
   LDX   sampledTMR+4   ; load low word of latched timer
   LDD   sampledTMR+6
   BRA   opLOADIO_end
timer_mhz
   LDX   #0             ; return Mhz (1 for Thomson rtc)
   IFNE  CYCLE_TIMER
   LDD   #64
   ELSE
   LDD   #1
   ENDC
   BRA   opLOADIO_end

uart_read
   LDA   #1          ; read keyoard
   JSR   GETC
   TSTB
   BNE   opLOADIO_end
   CLRA
   BRA   opLOADIO_end
uart_write
   LDB   5,U         ; prints a character
   JSR   PUTC
   IFNE  LPR
   IFEQ  TRACE
   JSR   RSCO
   ENDC
   ENDC
   BRA   opSTOREIO_end

timer_latch
   LDB   5,U
   BITB  #2
   BEQ   opSTOREIO_end
   PSHS  U,CC        ; latches the current timer value
   ORCC  #$50
   LDU   #TIMER_CTR
   PULU  D,X
   STD   sampledTMR
   STX   sampledTMR+2
   PULU  D,X
   STD   sampledTMR+4
   STX   sampledTMR+6
   PULS  U,CC
   IFEQ  CYCLE_TIMER
   BRA   timer_latch_phi
   ELSE
   BRA   opSTOREIO_end
   ENDC

opLOADIO
   LDX   #0
   LDD   ,U
* phi board
   CMPD  #$000C
   BEQ   uart_rdy
   CMPD  #$0010
   BEQ   uart_read
   CMPD  #$0014
   BEQ   timer_low
   CMPD  #$0018
   BEQ   timer_high
* soft board
   CMPD  #$0024
   BEQ   uart_rdy
   CMPD  #$0028
   BEQ   uart_read
   CMPD  #$0100
   BEQ   timer_low
   CMPD  #$0104
   BEQ   timer_high
   CMPD  #$0200
   BEQ   timer_mhz
* default
uart_rdy
   LDD   #256        ; tell uart is rady to send
opLOADIO_end
   STX   2,U
   STD   ,U
   JMP   <fetch

opSTOREIO
   LDD   ,U
* phi board
   CMPD  #$000C
   BEQ   uart_write
   CMPD  #$0014
   BEQ   timer_latch
* soft board
   CMPD  #$0024
   BEQ   uart_write
   CMPD  #$0100
   BEQ   timer_latch
opSTOREIO_end
   LEAU  8,U         ; fixup stack
   JMP   <fetch

opLOAD
   LDA   2,U         ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   opLOADnorm
   BHI   opLOADIO    ; yes => io-specific
opLOADstk
   JSR   <getAddrL   ; load from stack
   LDD   ,X          ; load high word
   STD   ,U          ; store in TOS
   LDD   2,X         ; load lower word
   STD   2,U         ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction   
opLOADnorm
   JSR   <getAddrL   ; convert adress
   LDD   ,X          ; load high word
   STD   2,U         ; store in TOS
   LDD   2,X         ; load lower word
   STD   ,U          ; store in TOS
   JMP   <updatePC   ; resync PC page and execute next instruction

opSTORE
   LDA   2,U         ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   opSTOREnorm
   BHI   opSTOREIO   ; yes => io-specific code
opSTOREstk
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   4,U
   STD   ,X
   LDD   6,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back
opSTOREnorm
   JSR   <getAddrL   ; convert TOS to address & set page
   LDD   6,U
   STD   ,X
   LDD   4,U
   STD   2,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC   ; page has been modified, ensure PC-page is back

opPOPSP
   LDU   ,U
   JMP   <fetch
   
getAddrStk  
   LDA   2,U         ; chk IO range
   CMPA  #STK_SPACE/256
   BMI   getAddrStk2
   LDA   1,U
   EORA  #2
   STA   1,U
getAddrStk2
   JMP   getAddr

opLOADH
   BSR   getAddrStk  ; loads 16 bits
   LDD   ,X
outUnsigned
   STD   ,U
   LDD   #0
   STD   2,U
   JMP   <updatePC

opSTOREH
   BSR   getAddrStk  ; stores 16 bits
   LDD   4,U
   STD   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

opLOADB
   BSR   getAddrStk  ; loads 8 bits
   CLRA
   LDB   ,X
   BRA   outUnsigned

opSTOREB
   BSR   getAddrStk  ; stores 8 bits
   LDB   5,U
   STB   ,X
   LEAU  8,U         ; fixup stack
   JMP   <updatePC

***************************************
* COMPARISON
***************************************

opLESSTHAN
   LDD   ,U
   LEAU  4,U         ; fixup stack
   SUBD  ,U
   LDD   -2,U
   SBCB  3,U
   SBCA  2,U
   IFEQ  TEO_BUGFX
   BLT   outTRUE
   ELSE
   BMI   outTRUE
   ENDC
   BRA   outFALSE

opLESSTHANOREQUAL
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   STD   ,U
   LDD   -2,U
   SBCB  3,U
   SBCA  2,U
   IFEQ  TEO_BUGFX
   BLT   outTRUE
   BGT   outFALSE
   ELSE
   BMI   outTRUE
   BHI   outFALSE
   ENDC
   ORB   ,U
   ORB   1,U
   BNE   outFALSE
   BRA   outTRUE

opULESSTHAN
   PULU D,X
   CMPX  2,U
   BLO   outTRUE
   BHI   outFALSE
   SUBD  ,U
   BLO   outTRUE
outFALSE
   LDD   #0          ; writes 0 on top of stack
   STD   ,U
   STD   2,U
   JMP   <fetch

opULESSTHANOREQUAL
   PULU D,X
   CMPX  2,U
   BHI   outFALSE
   BLO   outTRUE
   SUBD  ,U
   BHI   outFALSE
outTRUE
   LDD   #0          ; write 1 on top of stack
   STD   2,U
   INCB
   STD   ,U
   JMP   <fetch

opEQ
   PULU D,X
   CMPX  2,U
   BNE   outFALSE
   SUBD  ,U
   BNE   outFALSE
   BRA   outTRUE

opNEQ
   PULU D,X
   CMPX  2,U
   BNE   outTRUE
   SUBD  ,U
   BNE   outTRUE
   BRA   outFALSE

***************************************
* SHIFT
***************************************

LSHIFTRIGHT MACRO
   LSRD
   ROR   ,U
   ROR   1,U
   ENDM

opLSHIFTRIGHT
   LEAU  4,U
   LDD   2,U
   BEQ   opLSHIFTRIGHT_
   LSR  -3,U
   BCC   opLSHIFTRIGHT2
   LSHIFTRIGHT
opLSHIFTRIGHT2
   LSR   -3,U
   BCC   opLSHIFTRIGHT4
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT4
   LSR   -3,U
   BCC   opLSHIFTRIGHT8
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
   LSHIFTRIGHT
opLSHIFTRIGHT8
   STD   2,U
   LSR   -3,U
   BCC   opLSHIFTRIGHT16
*   abcd --> 0abc  swapped  cdab --> bc0a
   LDA   3,U
   LDB   ,U
   STD   ,U
   CLRA
   LDB   2,U
   STD   2,U
opLSHIFTRIGHT16
   LSR   -3,U
   BCC   opLSHIFTRIGHT32
*  abcd --> 00ab  swapped cdab --> ab00
   LDD   2,U
   STD   ,U
   LDD   #0
   STD   2,U
opLSHIFTRIGHT32
   JMP   <fetch

opLSHIFTRIGHT_
   LDD   ,U
   LSR  -3,U
   BCC   opLSHIFTRIGHT_2
   LSRD
opLSHIFTRIGHT_2
   LSR   -3,U
   BCC   opLSHIFTRIGHT_4
   LSRD
   LSRD
opLSHIFTRIGHT_4
   LSR   -3,U
   BCC   opLSHIFTRIGHT_8
   LSRD
   LSRD
   LSRD
   LSRD
opLSHIFTRIGHT_8
   LSR   -3,U
   BCC   opLSHIFTRIGHT_16
   TFR   A,B
   CLRA
opLSHIFTRIGHT_16
   LSR   -3,U
   BCC   opLSHIFTRIGHT_32
   LDD   #0
opLSHIFTRIGHT_32
   STD   ,U
   JMP   <fetch

ASHIFTLEFT MACRO
   LSLD
   ROL   3,U
   ROL   2,U
   ENDM

opASHIFTLEFT
   LEAU  4,U
   LDD   ,U
   BEQ   opASHIFTLEFT_
   LSR   -3,U
   BCC   opASHIFTLEFT2
   ASHIFTLEFT
opASHIFTLEFT2
   LSR   -3,U
   BCC   opASHIFTLEFT4
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT4
   LSR   -3,U
   BCC   opASHIFTLEFT8
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
   ASHIFTLEFT
opASHIFTLEFT8
   STD   ,U
   LSR   -3,U
   BCC   opASHIFTLEFT16
* abcd --> bcd0 swapped cdab --> d0bc
   LDA   3,U
   LDB   ,U
   STD   2,U
   LDA   1,U
   CLRB
   STD   ,U
opASHIFTLEFT16
   LSR   -3,U
   BCC   opASHIFTLEFT32
* abcd --> cd00 swapped cdab --> 00cd   
   LDD   ,U
   STD   2,U
   LDD   #0
   STD   ,U
opASHIFTLEFT32
   JMP   <fetch

opASHIFTLEFT_
   LDD   2,U
   LSR   -3,U
   BCC   opASHIFTLEFT_2
   LSLD
opASHIFTLEFT_2
   LSR   -3,U
   BCC   opASHIFTLEFT_4
   LSLD
   LSLD
opASHIFTLEFT_4
   LSR   -3,U
   BCC   opASHIFTLEFT_8
   LSLD
   LSLD
   LSLD
   LSLD
opASHIFTLEFT_8
   LSR   -3,U
   BCC   opASHIFTLEFT_16
   TFR   B,A
   CLRB
opASHIFTLEFT_16
   LSR   -3,U
   BCC   opASHIFTLEFT_32
   LDD   #0
opASHIFTLEFT_32
   STD   2,U
   JMP   <fetch

ASHIFTRIGHT MACRO
   ASRD
   ROR   ,U
   ROR   1,U
   ENDM

opASHIFTRIGHT
   LEAU  4,U
   LDD   2,U
   LSR   -3,U
   BCC   opASHIFTRIGHT2
   ASHIFTRIGHT
opASHIFTRIGHT2
   LSR   -3,U
   BCC   opASHIFTRIGHT4
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT4
   LSR   -3,U
   BCC   opASHIFTRIGHT8
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
   ASHIFTRIGHT
opASHIFTRIGHT8
   STD   2,U
   LSR   -3,U
   BCC   opASHIFTRIGHT16
* abcd --> xabc  swapped cdab --> bcxa
   LDA   3,U
   LDB   ,U
   STD   ,U
   LDB   2,U
   SEX
   STD   2,U
opASHIFTRIGHT16
   LSR   -3,U
   BCC   opASHIFTRIGHT32
* abcd --> xxab swapped cdab --> abxx
   LDX   #0
   LDD   2,U
   STD   ,U
   BPL   opASHIFTRIGHT16x
   LDX   #-1
opASHIFTRIGHT16x
   STX   2,U
opASHIFTRIGHT32
   JMP   <fetch

***************************************
* CONTROL FLOW (PC RELATED)
***************************************

opEMULATE_x
   LSLB              ; B=1xxx xx00
   LSLB              ; B=xxxx x000
   BEQ   opASHIFTRIGHT32 ; fetch
   CLRA              ; D=0000 0000 xxxx x000
   LSLD              ; D=0000 000x xxxx 0000
   LSLD              ; D=0000 00xx xxx0 0000=x*32
   LDX   #0
   PSHU  D,X
   * BRA   opCALL

opCALL
   LDA   3,U
   LDB   ,U
   ANDB  #$C0        ; clear lower bit
   TFR   D,X         ; saves PC_PG

   LDD   ,U          ; fix lower bits
   ANDA  #$3F
   ADDA  #$A0
   EXG   Y,D         ; update PC_REG

   SUBA  #$A0        ; clear upper bits of old PC
   ADDA  <PC_PG+1    ; add page lower bits
   STD   ,U          ; store lower word of PC
   LDB   <PC_PG      , load pages upper bits
   CLRA              ; PC is 24 bits
   STD   2,U         ; store upper word of PC

   STX   <PC_PG      ; update PC page
   JMP   <updatePC

opPOPPC
   LDD   ,U          ; lower word of PC
   ANDA  #$3F        ; map 16k address to $A000...$DFFF
   ADDA  #$A0
   TFR   D,Y         ; update pc reg
   LDA   3,U
   LDB   ,U          ; load page field
   ANDB  #$C0        ; align 16k
   STD   <PC_PG      ; update high word of PC
   LEAU  4,U         ; fixup stack
   JMP   <updatePC_D ; update page etc

doBRANCH
   LDD   ,U
   LEAU  4,U
   STD   ,U
   LDD   -2,U
   STD   2,U
   * fall through
opPOPPCREL
   BSR   addPCREL
   BRA   opPOPPC

addPCREL
   TFR   Y,D
   SUBA  #$A0
   ADDA  <PC_PG+1
   SUBD  #1
   ADDD  ,U
   STD   ,U
   LDD   2,U
   ADCB  <PC_PG
   CLRA              ; 24 bits
   STD   2,U
   RTS

opCALLPCREL
   BSR   addPCREL
   BRA   opCALL

opEQBRANCH
   LDD   4,U
   BNE   noBRANCH
   LDD   6,U
   BEQ   doBRANCH
noBRANCH
   LEAU  8,U
   JMP   <fetch

opNEQBRANCH
   LDD   4,U
   BNE   doBRANCH
   LDD   6,U
   BNE   doBRANCH
   BRA   noBRANCH

opPUSHPC
   CLRA               ; 24 bits
   LDB   <PC_PG
   TFR   D,X
   
   TFR   Y,D
   SUBA  #$A0
   ADDA  <PC_PG+1
   SUBD  #1
   BCC   opPUSHPC2
   LEAX  -1,X
opPUSHPC2
   PSHU  D,X
   JMP   <fetch

***************************************
* INSTRUCTION TABLE
***************************************
opTable
   FDB   opBREAKPT            ;  0 %0000 0000
   FDB   opUNKNOWN            ;  1 %0000 0001
   FDB   opPUSHSP             ;  2 %0000 0010
   FDB   opUNKNOWN            ;  3 %0000 0011
   FDB   opPOPPC              ;  4 %0000 0100
   FDB   opADD                ;  5 %0000 0101
   FDB   opAND                ;  6 %0000 0110
   FDB   opOR                 ;  7 %0000 0111
   FDB   opLOAD               ;  8 %0000 1000
   FDB   opNOT                ;  9 %0000 1001
   FDB   opFLIP               ; 10 %0000 1010
   FDB   opNOP                ; 11 %0000 1011
   FDB   opSTORE              ; 12 %0000 1100
   FDB   opPOPSP              ; 13 %0000 1101
   FDB   opUNKNOWN            ; 14 %0000 1110
   FDB   opUNKNOWN            ; 15 %0000 1111

   FDB   opADDSP_x            ; 16 %0001 0000
   FDB   opADDSP_x            ; 17 %0001 0001
   FDB   opADDSP_x            ; 18 %0001 0010
   FDB   opADDSP_x            ; 19 %0001 0011
   FDB   opADDSP_x            ; 20 %0001 0100
   FDB   opADDSP_x            ; 21 %0001 0101
   FDB   opADDSP_x            ; 22 %0001 0110
   FDB   opADDSP_x            ; 23 %0001 0111
   FDB   opADDSP_x            ; 24 %0001 1000
   FDB   opADDSP_x            ; 25 %0001 1001
   FDB   opADDSP_x            ; 26 %0001 1010
   FDB   opADDSP_x            ; 27 %0001 1011
   FDB   opADDSP_x            ; 28 %0001 1100
   FDB   opADDSP_x            ; 29 %0001 1101
   FDB   opADDSP_x            ; 30 %0001 1110
   FDB   opADDSP_x            ; 31 %0001 1111

   FDB   opEMULATE_x          ; 32 %0010 0000
   FDB   opUNKNOWN            ; 33 %0010 0001
   FDB   opLOADH              ; 34 %0010 0010
   FDB   opSTOREH             ; 35 %0010 0011
   FDB   opLESSTHAN           ; 36 %0010 0100
   FDB   opLESSTHANOREQUAL    ; 37 %0010 0101
   FDB   opULESSTHAN          ; 38 %0010 0110
   FDB   opULESSTHANOREQUAL   ; 39 %0010 0111
   FDB   opSWAP               ; 40 %0010 1000
   FDB   opMULT               ; 41 %0010 1001
   FDB   opLSHIFTRIGHT        ; 42 %0010 1010
   FDB   opASHIFTLEFT         ; 43 %0010 1011
   FDB   opASHIFTRIGHT        ; 44 %0010 1100
   FDB   opCALL               ; 45 %0010 1101
   FDB   opEQ                 ; 46 %0010 1110
   FDB   opNEQ                ; 47 %0010 1111

   FDB   opNEG                ; 48 %0011 0000
   FDB   opSUB                ; 49 %0011 0001
   FDB   opXOR                ; 50 %0011 0010
   FDB   opLOADB              ; 52 %0011 0011
   FDB   opSTOREB             ; 52 %0011 0100
   FDB   opDIV                ; 53 %0011 0101
   FDB   opMOD                ; 54 %0011 0110
   FDB   opEQBRANCH           ; 55 %0011 0111
   FDB   opNEQBRANCH          ; 56 %0011 1000
   FDB   opPOPPCREL           ; 57 %0011 1001
   FDB   opEMULATE_x          ; 58 %0011 1010 opCONFIG
   FDB   opPUSHPC             ; 59 %0011 1011
   FDB   opEMULATE_x          ; 60 %0011 1100 opSYSCALL
   FDB   opPUSHSPADD          ; 61 %0011 1101
   FDB   opMULT16X16          ; 62 %0011 1110
   FDB   opCALLPCREL          ; 63 %0011 1111
(info)

***************************************
* MONITOR and TRACING
***************************************

OPCDE MACRO
   FCC   \0
   FCB   \1+0
   ENDM

   IFNE  TRACE
doTRACE
   PSHS  CC,DP,D,X,Y,U
   LEAX  ,U
   LDU   #traceFmt
doTRACE1
   LDB   ,U+
   BEQ   endTRACE
   CMPB  #'%
   BNE   doTRACE2
   BSR   doTRACE3
   BRA   doTRACE1
doTRACE2
   JSR   PUTCHAR
   BRA   doTRACE1
endTRACE
   PULS  CC,DP,D,X,Y,U,PC

doTRACE3
   LDB   ,U+            ; decodes %thing
   CMPB  #'s
   BEQ   printSTACK
   CMPB  #'p
   BEQ   printPC
   CMPB  #'o
   BEQ   printOP
   CMPB  #'a
   BEQ   printASM
   CMPB  #'u
   BEQ   printSP
   RTS

printSP
   PSHS  X              ; prints 16bit stack ptr
   LEAX  12,S
   JSR   HEX16
   PULS  X,PC

printOP
   LDB   ,y             ; prints 8bit op-code
   JMP   HEX

printPC
   PSHS  D,X            ; prints 24bit PC reg
   TFR   Y,D
   SUBA  #$A0
   ORA   <PC_PG+1
   PSHS  D
   CLRA
   LDB   <PC_PG
   PSHS  D
   LEAX  1,S
   JSR   HEX8
   JSR   HEX16
   LEAS  ,X
   PULS  D,X,PC

printSTACK
   CMPX  #$A000
   BLO   HEX32swap
   JSR   PUTSTR
   COLOR 4
   IFNE  LPR
   FCC   /-------/
   FCB   128+'-
   ELSE
   FCC   /--------/
   ENDC
   COLOR 128+COLOR_STACK
   RTS

HEX32swap
   LEAX  2,X
   JSR   HEX16
   LEAX  -4,X
   JSR   HEX16
   LEAX  2,X
   RTS
   
printASM
   PSHS  X,U
   LDU   #asmTbl           ; find the #B th entry in table
   LDB   ,Y
   BPL   srchMNEMO

   JSR   PUTSTR            ; IM d
   FCC   /IM/
   FCB   128+32
   LSLB
   ASRB
   BRA   noXOR

srchMNEMO
   LDA   #32
   INCB
srchLOOP
   CMPA  ,U
   BHI   skipMNEMO
   LEAX  ,U+
skipMNEMO
   CMPA  ,U+
   BLS   skipMNEMO
   DECB
   BNE   srchLOOP
   LDB   ,X+
printOPCDE
   JSR   PUTCHAR
   LDB   ,X+
   CMPB  #32
   BHS   printOPCDE
   TSTB
   BEQ   noDECIMAL
   ANDB  ,y
printDECIMAL
   LDA   #%01000000
   ANDA  ,y
   BEQ   noXOR
   EORB  #$10
noXOR
   JSR   DECIMAL
noDECIMAL
   PULS  X,U,PC

COLOR_ST    SET   2
COLOR_PC    SET   3
COLOR_OP    SET   6
COLOR_INST  SET   5
COLOR_STACK  SET  4


traceFmt
   IFEQ  LPR

* nice colorful trace
   * IFEQ  LPR
   * FCB   10,10,11,11
   * ENDC
   COLOR COLOR_STACK
   FCC   /%s %s %s %s/
   FCB   13,10
   COLOR COLOR_ST
   FCC   /%u /
   COLOR COLOR_PC
   FCC   /%p /
   COLOR COLOR_OP
   FCC   /%o /
   COLOR COLOR_INST
   FCC   /%a/
   COLOR COLOR_STACK
   FCB   13,10,0

   ELSE

* compatible with zpu.c
   FCC   /0x0%p 0x%o 0x%u/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   FCC   / 0x%s 0x%s 0x%s 0x%s/
   fcc   / %a/
   FCB   10,0

   ENDC

asmTbl
   OPCDE /BREAKPT/            ; 0
   OPCDE /???/                ; 1
   OPCDE /PUSHSP/             ; 2
   OPCDE /???/                ; 3
   OPCDE /POPPC/              ; 4
   OPCDE /ADD/                ; 5
   OPCDE /AND/                ; 6
   OPCDE /OR/                 ; 7
   OPCDE /LOAD/               ; 8
   OPCDE /NOT/                ; 9
   OPCDE /FLIP/               ; 10
   OPCDE /NOP/                ; 11
   OPCDE /STORE/              ; 12
   OPCDE /POPSP/              ; 13
   OPCDE /???/                ; 14
   OPCDE /???/                ; 15
   OPCDE /ADDSP/,32           ; 16..31
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   FCB   15,15,15,15
   OPCDE /EMULATE/,32         ; 32
   FCB   31
   OPCDE /???/                ; 33
   OPCDE /LOADH/              ; 34
   OPCDE /STOREH/             ; 35
   OPCDE /LESSTHAN/           ; 36
   OPCDE /LESSTHANOREQUAL/    ; 37
   OPCDE /ULESSTHAN/          ; 38
   OPCDE /ULESSTHANOREQUAL/   ; 39
   OPCDE /SWAP/               ; 40
   OPCDE /MULT/               ; 41
   OPCDE /LSHIFTRIGHT/        ; 42
   OPCDE /ASHIFTLEFT/         ; 43
   OPCDE /ASHIFTRIGHT/        ; 44
   OPCDE /CALL/               ; 45
   OPCDE /EQ/                 ; 46
   OPCDE /NEQ/                ; 47
   OPCDE /NEG/                ; 48
   OPCDE /SUB/                ; 49
   OPCDE /XOR/                ; 50
   OPCDE /LOADB/              ; 51
   OPCDE /STOREB/             ; 52
   OPCDE /DIV/                ; 53
   OPCDE /MOD/                ; 54
   OPCDE /EQBRANCH/           ; 55
   OPCDE /NEQBRANCH/          ; 56
   OPCDE /POPPCREL/           ; 57
   OPCDE /CONFIG/             ; 58
   OPCDE /PUSHPC/             ; 59
   OPCDE /SYSCALL/            ; 60
   OPCDE /PUSHSPADD/          ; 61
   OPCDE /MULT16X16/          ; 62
   OPCDE /CALLPCREL/          ; 63
   OPCDE /STORESP/,32         ; 64..95
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   OPCDE /LOADSP/,32         ; 96..127
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31
   FCB   31,31,31,31

(info)
   ENDC

FILENAME
   FCC   /0:/
   FCC   /dhryston/
   * FCC   /test    /
   * FCC   /test2   /
   * FCC   /a       /
   * FCC   /eliza   /
   FCC   /bin/
   FCB   0

FAT
   RMB   256
BUF
   RMB   256

***************************************
* Hello world example
***************************************
   * ORG   $A000

* INCDAT dhryston.bin

   IFNE  0
* https://github.com/tobyjaffey/libzpu/blob/master/zpusim-mini/zpusim-mini.c
   FCB   $80,$3d,$0d,$f8,$80,$80,$82
   FCB   $80,$51,$80,$c8,$71,$0c,$80
   FCB   $e5,$71,$0c,$80,$ec,$71,$0c
   FCB   $80,$ec,$71,$0c,$80,$ef,$71
   FCB   $0c,$a0,$71,$0c,$80,$d7,$71
   FCB   $0c,$80,$ef,$71,$0c,$80,$f2
   FCB   $71,$0c,$80,$ec,$71,$0c,$80
   FCB   $e4,$71,$0c,$8d,$71,$0c,$8a
   FCB   $71,$0c,$00,$82,$3d,$0d,$04
   ENDC
HEAP

   END   main
