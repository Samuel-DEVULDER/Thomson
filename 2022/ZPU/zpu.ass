; COMmon part between opLD and opST depending on N flag
opLDSTsp
   BPL   opStoresp_x

; Load on stack the value at stack[x]
; B=-xxxxx00 (4*x)
opLoadsp_x
   ANDB  %01111100   ; clear bit 7 of 4*x
   LEAX  B,U         ; X points to source
   LDD   ,X          ; load high word
   LDX   2,X         ; load low word
   PSHU  D,X         ; push 32 bits
   BRA   fetch       ; next instruction

; Write top of stack at stack[x]
; B=0xxxxx00 (4*x)
opStoresp_x
   LEAX  B,U         ; X point to dest (bit7 already 0)
   LDD   ,U          ; load high word
   STD   ,X          ; store high word
   LDD   2,U         ; load low word
   STD   2,X         ; store low word
   LEAU  4,U         ; adjust the stack
   BRA   fetch       ; next instructio,

; Adds to TOS the value at stack[x]
; B=0--xxxx00 (4*x)
opAddsp_x
   ANDB  %00111100   ; make 4*x postitive
   LEAX  B,U         ; X point to source
   LDD   2,X         ; load low word of source
   ADDD  2,U         ; add low word of TOS
   STD   2,U         ; store result to TOS (lower word)
   LDD   ,X          ; load high word of source
   ADCB  1,U         ; add with carry the TOS (high word)
   ADCA  ,U          ; second byte
   STD   ,U          ; store result to TOS (high word)
   BRA   fetch       ; next instruction

; loads a continuated immediate value
; B=xxxxxxx0 (value*2)
opImX
   LSR   ,U          ; rotate TOS 7 bits left
   LDA   1,U
   RORA
   STA   ,U          ; byte 0 is byte 1 rotated right once
   LDA   2,U
   RORA
   STA   1,U         ; byte 1 is byte 2 rotated right once
   LDA   3,U
   RORA              ; byte 2 is byte 3 rotated right once
   RORB              ; push bit back to value
   STD   2,U         ; write lower word
   LDB   [fetch+1]   ; is next opcode an opIm?
   BMI   INCPC       ; yes => just increment PC
   LDA   #CMPA       ; no => disable hook
   STA   <opIm       ; (write CMPA as the first instructon of opIm)
   BRA   INCPC       ; next instruction (B already fetched)

; loads a 7 bit immediate value
; B=xxxxxxx0 (value*2)
opIm:
   BRN   opImX       ; hook to go to continued version (dynamic code)
   ASRB              ; left align signed value
   SEX               ; extends sign to A ($00 or $FF)
   PSHS  D           ; push lower word
   STA   ,-U         ; push high byte (sign)
   STA   ,-U         ; push high byte (sign)
   LDB   [fetch+1]   ; is next opcode an immediate value?
   BPL   INCPC       ; no => no change in hook. just update the PC reg.
   LDA   #BRA        ; yes => mak hook go to opImX
   STA   <opIm       ; (write a BRA as the first instructio, of opIm)
   BRA   INCPC       ; next instruction (B already fetched)

; safe version of getAddr for long values
getAddrLong
   if safe
   LDB   #%11111100
   ANDB  3,U         ; just clear the 2 lower bits of TOS
   STB   3,U
   endc

; make X points to the address in TOS (stack unmodified)
getAddr
   LDD   2,U         ; load lower part of the address
   ANDA  #$30        ; clear high bits
   ADDA  #$a0        ; make it point to $A000...$DFFF
   TFR   D,X         ; X opdated
   LDD   1,U         ; load 16kb page section of address

; updates page when neeeded
; D=high bytes of the 24bits address
updatePage
   ANDB  #$c0        ; just keep the 2 top bits
   CMPD  #page       ; compare wit current page index
page equ*-2          ; page index (dynamic code)
   BEQ   updatePage2 ; same => just return
   STD   <page       ; different => update page index
   LSLB              ; compute the proper memory bank
   ROLA
   LSLB
   ROLA
; map proper bank onto $A000...$DFFF space
; A=bank number
bank
   STA   $e7e6       ; need to check, might use PIA instead
updatePage2
   RTS               ; done

; restore the page back to the instruction page
updatePC
    LDD  #pchigh     ; load instruction page
pchigh set *-2       ; instruction page (dynamic code)
    BSR  updatePage  ; update page if needed

; fetches and execute an instruction
fetch
   LDB   >$a000      ; load instruction byte
INCPC
   INC   <fetch+2    ; update lower byte of the PC
   BNE   decode      ; no overflow => just decode instruction
   INC   <fetch+1    ; update upper part of the PC
   LDA   <fetch+l
   CMPA  #$E0        ; crossing $E000 ?
   BNE   decode      ; no => just decode the instruction
   LDA   #$A0        ; yes => next instruction page
   STA   <fetch+1    ; make PC point to $A000
   PSHS  B           ; saves current opcode
   LDD   <updatePC+1 ; advance instruction page
   ADDD  #$40        ; by 16kb (a memory bank)
   STD   <updatePC+1 ; update instruction page
   PULS  B
   BSR   updatePage  ; update bank

; deocdes the current opcode (in B)
decode:
   LSLB              ; double the opcode
   BCS   opIm        ; opcode=1xxxxxxx ? yes => immediate value
   LSLB              ; else make B = xxxxxx00
   BCS   opLDSTsp    ; opcode=01xxxxxx ? yes => LDsp_x or STsp_x
   BMI   opEmulate_x ; opcode=001xxxxx ? yes => emulate_x
   BITB  #%01000000  ; opcode=0001xxxx ? yes => addsp_x
   BNE   opAddsp_x   ; at this point opcode=0000xxxx
   CLRA              ; we use a lookup table
   LSLB
   LSLB
   LSLB
   ROLA              ; D=opcode*32
   JMP   D,pc        ; jump to proper implemetation of opcode

;    34*4 136*4 272-256=12

emulate_x
   LDX   #lo1dH-34*32
   LSLB              ; lookup table here to
   LSLB              ; opcode*16
   ABX               ; use ABX because B is unsigned byte
   ABX               ; X=lo1dH-34*32+opcode*32
   JMP   ,X

; start of operation table
optab set *

; macro to align operation correctly wrt "optab"
opcode macro
tmp set optab+32*\0
   ifgt *-tmp
   error overflow
   else
   RMB tmp-*,$12     ; align znf fill with NOPs
   endif
   endm

   opcode %0000
breakpt
   BRA   breakpt     ; do nothing (breakpoint)

   opcode %0001
op0001
   BRA   op0001      ; unexistant opcode

   opcode %0010
opPushsp:
   LDD   #0
   LEAX  ,U
   PSHU  D,X
   JMP   <fetch

   opcode %0011
op0011:
   JMP   op0011

   opcode %0100
opPoppc:
   LDD   2,U
   ANDA  #$03
   ADDA  #$a0
   STD   <fetch+1
   LDD   1,U
   STD   <pcHigh
   LEAU  4,U
   JMP   <updatePC+3

   opcode %0101
opAdd:
   LEAU  4,U
   LDD   2,U
   ADDD  -2,U
   STD   2,U
   LDD   ,U
   ADCB  -3,U
   ADCA  -4,U
   STD   ,U
   JMP   <fetch

   opcode %0110
opAnd:
   LDD   ,U
   LEAU  4,U
   ANDA  ,U
   ANDB  2,U
   STD   ,U
   LDD   -2,U
   ANDA  2,U
   ANDB  3,U
   STD   2,U
   JMP   <fetch

   opcode %0111
opOr:
   LDD   ,U
   LEAU  4,U
   ORA   ,U
   ORB   2,U
   STD   ,U
   LDD   -2,U
   ORA   2,U
   ORB   3,U
   STD   2,U
   JMP   <fetch

   opcode %1000
opLoad:
   BSR   getAddrLong
   LDD   ,X
   STD   ,U
   LDD   2,X
   STD   2,U
   JMP   <updatePC

   opcode %1001
opNot:
   COM   ,U
   COM   1,U
   COM   2,U
   COM   3,U
   JMP   <fetch

flip2
   LSLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ROLA
   RORB
   ADCA  #0
   RTS

   opcode %1010
opFlip:
   LDA   ,U
   LDB   3,U
   BSR   flip2
   STA   ,U
   STB   3,U
   LDD   1,U
   BSR   flp2
   STD   1,U
   JMP   <fetch

   opcode %1011
opNop:
   JMP   <fetch

   opcode %1100
opStore:
   BSR   getAddrLong
   LDD   4,U
   STD   ,X
   LDD   6,U
   STD   2,X
   LEAU  8,U
   JMP   <updatePC

   opcode %1101
opPopsp:
   pulu  D,X
   LEAU  ,X
   JMP   <fetch

   opcode %1110
opStore:
   BSR   getAddr
   LEAU  8,U
   LDD   -4,U
   STD   ,X
   LDD   -2,U
   STD   2,X
   JMP   <updatePC

  opcode %1111
op1111:
   BRA   op1111

optab EQU *

   opcode 34-34
opLoadH
   BSR   getAddr
   LDX   ,X
   BMI   opLoadH2
   LDD   #0
opLoadH1
   PSHU  D,X
   JMP   <updatePC
oploadH2
   LDD   #-1
   PSHU  D,X
   JMP   <updatePC

   opcode 35-34
opStoreH
   BSR   getAddr
   LEAU  8,U
   LDD   -2,U
   STD   ,X
   JMP   <updatePC

   opcode 36-34
opLessThan
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BLT   TOS_1
   BGT   TOS_0
   LDD   -2,U
   SUBD  2,U
   BMI   TOS_1

; writes 0 on top of stack
TOS_0
   LDD   #0
   STD   ,U
   STD   2,U
   JMP   <fetch

   opcode 37-34
opLessThanOrEqual
   LDD   ,U
   LEAU  4,U
   SUBD  ,U
   BGT   TOS_0
   BLT   TOS_1
   LDD   -2,U
   SUBD  2,U
   BPL   TOS_0

; write 1 on top of stack
TOS_1
   LDD   #0
   STD   ,U
   INCB
   STD   2,U
   JMP   <fetch
