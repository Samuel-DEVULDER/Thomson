(main)B2
**************************************
* Raytraced scene featuring a
* green/yellow checkerboard ground,
* blue sky, and two reflective sphres
*
* Inspired from!
*     https://bbcmic.ro/?t=9ctpk
*
* (c) Samuel DEVULDER, 2024
**************************************

USE_XTRA equ   0

TIMEPT   equ   $6027
STATUS   equ   $6019
FORME    equ   $6038
CHDRAW   equ   $6041
PTGENE   equ   $60CF

PUTC     equ   $E803
KTST     equ   $E809
*PLOT     equ   $E80F
KBIN     equ   $E830
SETP     equ   $EC00
EXTRA    equ   $EC0C

DBLFLG   equ   $6103
VALTYP   equ   $6105

FACEXP   equ   $614E
FACHO    equ   $614F
FACMO    equ   $6150
FACLO    equ   $6151
FACSGN   equ   $6156

ARGEXP   equ   $6159
ARGHO    equ   $615A
ARGMO    equ   $615B
ARGLO    equ   $615C
ARGSGN   equ   $6161

**************************************

ldab     macro
         ldd   #(\0)*256+\1
         endm

clrd     macro
*         clrb
*         clra
         ldab  0,0
         endm
         
negd     macro
         nega
         negb
         sbca  #0
         endm

lsrd     macro
         lsra
         rorb
         endm
         
lsld     macro
         lslb
         rola
         endm
         
absb     macro
         bge   *+3
         negb
         endm

**************************************
* floating point pseudo instructions
**************************************

* enter fpu section
f_beg    macro
         ldu   #*+6
         fcb   $7E   ; jmp
         endm
         
* exit fpu section
f_end    macro
         fdb   *+2
         endm

* jump
f_jmp    macro
         fdb   fjmp,\0
         endm

* jump to subroutine
f_jsr    macro
         fdb   fjsr,\0
         endm

* return from subroutine
f_rts    macro
         fdb   frts
         endm

* load FAC
f_ld0    macro
         fdb   movfm,\0
         endm

* load ARG
f_ld1    macro
         fdb   movam,\0
         endm

MOVMF    macro
         lda   <FACEXP
         ldb   <FACSGN
         orb   #127
         andb  <FACHO
         std   \0
         lda   <FACMO
         sta   \0+2
         pulu  pc
         endm

* store         
f_sto    macro
         fdb   movmf,\0
         endm
         
* store & load FAC
f_sl0    macro
*         f_sto \0
*         f_ld0 \1
         fdb   movmfm,\0,\1
         endm
         

* tfr FAC --> ARG
f_tfr    macro
         fdb   movaf
         endm

f_mul4   macro
         fdb   fastMul4
         endm
   
* addition
f_add    macro
         fdb   fadd
         endm

f_ad1    macro
         fdb   fad1,\0
         endm
         
* subtraction
f_sub    macro
         fdb   fsub
         endm

f_sb1    macro
         fdb   fsb1,\0
         endm

* multiplication
f_mul    macro
         fdb   fmul
         endm

f_ml1    macro
         fdb   fml1,\0
         endm
         
* division
f_div    macro
         ifne  USE_XTRA
         fdb   fdiv
         else
         fdb   fDivEnt
         f_newton
         f_sqr
         f_ml1 fDivX
         endc
         endm

* greatest integer below or equal
f_floor  macro
         fdb   floor
         endm

* negate
f_neg    macro
         fdb   fneg
         endm
         
* square
f_sqr    macro
         ifne  USE_XTRA
         fdb   movaf,fmul
         else
         fdb   fsqr
         endc
         endm
         
* square root 
f_sqrt   macro
         ifne  USE_XTRA
         fdb   fsqrt
         else
         f_isqrt
         f_ml1 fISqrtX
         endc
         endm
         
* inverse square root
f_isqrt  macro
         ifne  USE_XTRA
         f_sqrt
         f_ld1 c_1
         f_div
         else
         fdb   fInvSqrtMagic
         f_newton
         endc
         endm
         
f_newton macro
         f_ml1 fISqrtX       ; x*y*y
         f_sb1 c_3           ; 3 - x*y*y
         fdb   fml05,fISqrtY ; y*(1.5 - 0.5*x*y*y)
         endm
         
* cast to int 
f_int    macro
         f_ad1 c_0p5
         f_floor
         fdb   ftoi
         endm

**************************************

         org   $9000
         setdp $61

ini      pshs  dp
         ldd   #$6104
         tfr   a,dp
         ifne  USE_XTRA
* init extramon + math         
         stb   <VALTYP
         clr   <DBLFLG         
         ldb   #1
         jsr   EXTRA
         endc
* init screen
         ldx   #palette
         lda   #$FF
         jsr   SETP
         ldx   #inistr
         jsr   puts        
* init conversion entier->float
         ldd   #319
         ldx   #fCoord+320*2
fCo1     pshs  d
         std   ,--x
         lda   #$90
         ldb   ,x
fCo2     deca
         lsl   1,x
         rolb
         bpl   fCo2
         std   ,x
         puls  d 
         subd  #1
         bne   fCo1
         std   ,--x
* init timer         
         ldd   #timert
         std   >TIMEPT
         ldb   #$20
         orb   >STATUS
         stb   >STATUS
         andcc #255-$50    ; enable interrupts
         clrd
         std   <fI+2
         stb   >CHDRAW
         std   <iTime      ; rester time counter
         
* init pseudo-random point generator         
         std   <iRnd
newpx    bra   calcXY

drwpx    stb   FORME
         ldx   <iX
         ldy   <iY
         jsr   PLOT        
         
nxtpx    ldd   <iRnd
nxrnd    set   *
         lsld           ; 2*iRnd
         lsld           ; 4*iRnd
         addd  <iRnd    ; 5*iRnd
         addd  #1       ; 5*iRnd+1
         anda  #127 
         std   <iRnd    ; iRnd = (5*iRnd+1) and 32767
         beq   done
         
         cmpd  #32000
         bcs   newpx
         bra   nxrnd    ; loop if >= 32000

done     ldx   #0       ; x=0
         leay  ,x       ; y=0
         jsr   prtTime  

         ldb   #7
         jsr   PUTC     ; beep
         
wait_key jsr   KTST     ; wait key press
         bcc   wait_key
   
         puls  dp,pc

calcXY    
         ifne 0
         
         std   <ARGMO
         ldd   #200
         jsr   idivmod
         std   <iX
         lsld
         std   <i2X
         ldd   <ARGMO
         
         else
* fait gagner 15sec environ
         ldx   #0
calcXY1  cmpa  #100
         bcs   calcXY2
         suba  #100
         leax  128,x
calcXY2  cmpa  #50
         bcs   calcXY3
         suba  #50
         leax  64,x
calcXY3  cmpa  #25
         bcs   calcXY4
         suba  #25
         leax  32,x
calcXY4  cmpd  #3200
         bcs   calcXY5
         subd  #3200
         leax  16,x
calcXY5  cmpd  #1600
         bcs   calcXY6
         subd  #1600
         leax  8,x
calcXY6  cmpd  #800
         bcs   calcXY7
         subd  #800
         leax  4,x
calcXY7  cmpd  #400
         bcs   calcXY8
         subd  #400
         leax  2,x
calcXY8  cmpd  #200
         bcs   calcXY9
         subd  #200
         leax  1,x
calcXY9  stx   <iX
         stx   <i2X
         lsl   <i2X+1
         rol   <i2X
         
         endc
        
         std   <iY         
         sta   fX

         ldd   #$7DCC   ; -.1
         std   fY
*         incb
         stb   fY+2
         
         ldd   #$8240   ; 3
         std   fZ
         clr   fZ+2

*         bra   calcUVW
         
calcUVW  ldd   <i2X
         bsr   itof
         f_beg
         f_ad1 c_m159p5
         f_ml1 c_1o130
         f_sto fU       ; U = (2M-159.5)/130
         f_end
         
         ldd   <iY
         bsr   itof
         f_beg
         f_sb1 c_99p5
         f_ml1 c_1o130
         f_sto fV       ; V = (99.5-N)/130
         
         f_sqr 
         f_sl0 fT,fU    ; T = V*V

         f_sqr          ; U*U
         f_ad1 fT       ; U*U + V*V
         f_ad1 c_1      ; U*U + V*V + 1
         
         f_isqrt 
         f_sto fW       ; W = 1/sqrt(1+U*U+V*V)
         
         f_ml1 fV       ; V=V*W
         f_sl0 fV,fW
         
         f_ml1 fU       ; U=U*W
         f_sto fU
         f_end
         
*        bra   spheres
 
sph_w    equ   48
sph_h    equ   48
 
* speedup : use sphere bounding_box to 
* decide if we do the full sphere computation
* or directly go to sky or ground
chk_spheres  
         ldx   #c_sph-6
nxt_sphere
         leax  6,x
         ldd   ,x
         bge   bb_sphere
no_sphere         
         jmp   ground_or_sky

itof     ldx   #fCoord
         lsld
         ldd   d,x
         std   <FACEXP
         clrd
         std   <FACMO
         sta   <FACSGN
         rts

bb_sphere
         subd  <i2X
         absb
         cmpb  #sph_w
         bhi   nxt_sphere
         ldd   2,x
         beq   no_sphere
         subd  <iY
         absb
         cmpb  #sph_h
         bhi   nxt_sphere
         ldd   4,x
         std   <fI      ; I = +/- 1 depending on the bounding-box
         bra   sphere_bounce
                           
sphere_EFP
         f_ld0 fI
         f_ad1 fX
         f_sl0 fE,fI    ; E=X+I
         f_ad1 fY
         f_sto fF       ; F=Y+I

         f_ml1 fV
         f_sl0 fP,fU    ; P=V*F
         f_ml1 fE       ; U*E
         f_ad1 fP       ; P = U*E + V*F
         f_sl0 fP,fW
         f_ml1 fZ       ; W*Z
         f_sb1 fP       ; P=V*F + U*E - W*Z
         f_sto fP
         
         f_rts

if_le0_then_ground_or_sky
         ldb   <FACEXP  ; IF T>0 THEN
         beq   *+8
         ldb   <FACSGN
         bmi   *+4
         pulu  pc
         jmp   ground_or_sky

sphere_bounce
         f_beg
         f_jsr sphere_EFP

         f_sqr 
         f_sl0 fT,fE    ; T=P*P         
         f_sqr         
         f_sb1 fT       ; T -= E*E
         f_sl0 fT,fF
         f_sqr         
         f_sb1 fT       ; T -= F*F  
         f_sl0 fT,fZ
         f_sqr
         f_sb1 c_1      ; 1 - Z*Z
         
         f_ad1 fT       ; P*P - E*E - F*F - Z*Z + 1
         
         fdb   if_le0_then_ground_or_sky  ; IF T>0 THEN
         
         f_sqrt
         f_ad1 fP 
         f_neg          ; -(P + SQR(T))
         
         fdb   if_le0_then_ground_or_sky  ; IF T>0 THEN
                  
         f_sto fT
         f_ml1 fU
         f_ad1 fX       ; X=X+U*T
         f_sl0 fX,fT
         f_ml1 fV
         f_ad1 fY       ; Y=Y+V*T
         f_sl0 fY,fT
         f_ml1 fW
         f_sb1 fZ       ; Z=Z-W*T
         f_sto fZ
         
         f_jsr sphere_EFP
         
         fdb   f2Pld    ; P=2P; f_ld0 P
         f_ml1 fE
         f_sb1 fU       ; U=U-P*E
         f_sl0 fU,fP
         f_ml1 fF
         f_sb1 fV      ; V=V-P*F
         f_sl0 fV,fP
         f_ml1 fZ
         f_ad1 fW       ; W=W+P*Z
         f_sto fW
         
         f_end
         ldb   #128
         eorb  <fI+1
         stb   <fI+1    ; I=-I
         jmp   sphere_bounce         

ground_or_sky         
         ldb   fV+1
         bmi   ground
sky
         f_beg
         f_ld0 fV
         f_sqrt 
         f_ml1 c_7
         f_sto fV       ; V=7*sqrt(V)
         f_jmp calcCOL

ground        
         f_beg
         f_ld0 c_2
         f_ad1 fY 
         f_tfr
         f_ld0 fV
         f_div 
         f_sto fP       ; P=(Y+2)/V
         
         f_ml1 fU       ; U*P
         f_sb1 fX       ; X-U*P
         f_floor        ; T=floor(X-U*P)
         f_sl0 fT,fP
         f_ml1 fW       ; W*P
         f_sb1 fZ       ; Z-W*P
         f_floor

         f_ad1 fT
         f_int
         
         fdb   setDalle
         
         f_ld0 fV
         f_neg 
         f_sqrt
         f_mul4      ; 4*SQR(-V)

* V=8+5*((INT(X-U*P)+INT(Z-W*P))AND1)+4*SQR(-V)
         f_ad1 ground0
dalle    set   *-2           
         f_sto fV
*        f_jmp calcCOL

calcCOL  fdb   dither
         f_ad1 fV
         f_int
         f_end
         ldx   #cols
         ldb   b,X
         jmp   drwpx    
         
dither   ldx   #vac
         ldb   <iY+1
         andb  #7
         lslb
         abx
         ldab  16,7
         andb  <iX+1
         mul
         ldd   d,x
         stb   <FACSGN
         orb   #128
         std   <FACEXP
         clra
         sta   <FACMO
         pulu  pc

setDalle ldx   #ground0
         lsrb
         bcc   *+5
         ldx   #ground1
         stx   >dalle
         pulu  pc

fjmp     ldu   ,u
         pulu  pc

fjsr     leax  2,u
         ldu   ,u
         pshs  x
         pulu  pc
         
frts     puls  u
         pulu  pc
         
movafm   pulu  x,y
         ldd   ,x
         stb   <FACSGN
         orb   #128
         std   <FACEXP
         lda   2,x
         sta   <FACMO
         ldd   ,y
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   2,y
         sta   <ARGMO
         pulu  pc
             
movam    pulu  x,y
         ldd   ,x
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   2,x
         sta   <ARGMO
         jmp   ,y 

f2Pld    ldx   #fP
*         ldb   ,x
*         beq   *+4
         inc   ,x      ; P=2*P
         pulu  y
         bra   movfm+2


movfm    pulu  x,y
         ifne  USE_XTRA
         ldb   #62
         bra   xtra_y
         else
         ldd   ,x
         stb   <FACSGN
         orb   #128
         std   <FACEXP
         lda   2,x
         sta   <FACMO
         jmp   ,y
         endc

movmf    pulu  x,y
         ifne  USE_XTRA
         ldb   #63
         bra   xtra_y
         else
         lda   <FACEXP
*         bne   movmf1
*         sta   ,x
*         jmp   ,y
movmf1   ldb   <FACSGN
         orb   #127
         andb  <FACHO
         std   ,x
         lda   <FACMO
         sta   2,x
         jmp   ,y
         endc

movaf    set   *     
         ifne  USE_XTRA
         ldb   #64
         bra   xtra
         else
         ldd   <FACEXP
         std   <ARGEXP
         lda   <FACMO
         sta   <ARGMO
         lda   <FACSGN
         sta   <ARGSGN
         pulu  pc
         endc

movmfm   pulu  x,y
         lda   <FACEXP
         ldb   <FACSGN
         orb   #127
         andb  <FACHO
         std   ,x
         lda   <FACMO
         sta   2,x
         ldd   ,y
         stb   <FACSGN
         orb   #128
         std   <FACEXP
         lda   2,y
         sta   <FACMO
         pulu  pc  

fastMul4 ldb   <FACEXP
*        beq   *+6
         addb  #2
         stb   <FACEXP  ; FAC=4*FAC
         pulu  pc

         ifne  USE_XTRA
fdiv     ldb   #57
         bra   xtra
         else
fDivEnt  ldb   <ARGSGN
         eorb  <FACSGN
         orb   #127
         andb  <ARGHO
         lda   <ARGEXP
         std   fDivX
         lda   <ARGMO
         sta   fDivX+2

fInvSqrtMagic
         lda   <FACMO
         sta   <fISqrtX+2
               
         ldd   <FACEXP
         andb  #127     ; clr msbit
         std   <fISqrtX
         
         suba  #2       ; make bias = 127
         lslb           ; |
         lsrd           ; | make ieee
         
         lsrd           ; |
         ror   <FACMO   ; | i>>1
         std   <FACEXP  ; |
         
         lda   #$5b    ;  $5F375A86 - (i>>1)
         suba  <FACMO
         sta   <FACMO
         sta   <fISqrtY+2
         
         ldd   #$6037   ; includes bias correction
         sbcb  <FACHO
         sbca  <FACEXP

         addb  #128     ; extract msbit -> carry
         rola           ; move carry to a
         
         andb  #127     ; clr msbit
         std   <fISqrtY
         stb   <FACSGN  ; make result>0
         orb   #128     ; set msbit

         asla           ; compute square   
         adda  #$80
         std   <FACEXP
         lda   <FACMO
         ifne  0
         bra   fsqr1
         else
         mul         
         lsld
         sta   <FACMO
         lda   <FACHO
         ldb   <FACHO
         bcc   fInvSqrtMagic1
         mul
         addb  <FACMO
         adca  #1
         bpl   fmul1
         std   <FACHO
         pulu  pc
fInvSqrtMagic1
         mul
         addb  <FACMO
         adca  #0
         bpl   fmul1
         std   <FACHO
         pulu  pc
         endc
           
fsqr     lda   <FACEXP
         beq   fmul0+2
*         suba  #$80
         asla
*         bvs   fmulOvf
         adda  #$80
         sta   <FACEXP         
         ldd   <FACHO         
fsqr1    mul         
         lsld
         sta   <FACMO
         lda   <FACHO
         ldb   #0
         rolb   
         stb   <FACHO
         stb   <FACSGN     ; make result>0
         tfr   a,b
         mul
         addd  <FACHO
         bpl   fmul1
         std   <FACHO
         pulu  pc
         endc

         ifne  USE_XTRA
fsqrt    ldb   #44
         bra   xtra
         endc
                  
         ifne  USE_XTRA
xtra_y   jsr   >EXTRA
         jmp   ,y
         
xtra     jsr   >EXTRA
         pulu  pc
         
fmul     ldb   #56
         bra   xtra
         else
*fmulOvf  tfr   a,b      ;
*         sex   
fmul0    sta   <FACEXP
         pulu  pc  
         
fml05    dec   <FACEXP      ; 
fml1     pulu  x
         ldd   ,x
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   2,x
         sta   <ARGMO
*        bra   fmul

* multiplication with 16 bit mantissa
fmul     lda   <FACEXP
         beq   fmul0+2
*         suba  #$80
*         sta   <FACEXP

         lda   <ARGEXP
         beq   fmul0

*         suba  #$80
         adda  <FACEXP
*         bvs   fmulOvf
         adda  #$80
         sta   <FACEXP
         
         lda   <ARGSGN
         eora  <FACSGN
         sta   <FACSGN
         
         lda   <FACMO
         ldb   <ARGHO
         mul
*        adca  #0       ; a += b7 (seem unnecessary)
         sta   <FACMO

         ldb   <ARGMO
         lda   <FACHO
         mul
         adca  <FACMO
         sta   <FACMO
      
         lda   <FACHO
         ldb   #0       ; move carry to FACHO
         rolb            
         stb   <FACHO
         
         ldb   <ARGHO           
         mul                     
         addd  <FACHO
         bmi   fmul2
fmul1    dec   <FACEXP
         beq   fmul2    ; underflow
         lsld
*         bpl   fmul1
fmul2    std   <FACHO
         pulu  pc
         endc

fneg     com   <FACSGN
         pulu  pc

fsb1     pulu  x
         ldd   ,x
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   2,x
         sta   <ARGMO
*         bra   fsub
         
         ifne  USE_XTRA
fsub     ldb   #55         
         bra   xtra
         else
fsub     com   <FACSGN     ; ARG - FAC
         bra   fadd
         endc

fad1     pulu  x
         ldd   ,x
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   2,x
         sta   <ARGMO
*         bra   fadd

         ifne  USE_XTRA
fadd     ldb   #54
         bra   xtra
         else
fadd     ldb   <ARGEXP     ; ARG + FAC
         bne   *+4
         pulu  pc
         
         subb  <FACEXP     ; determine which is bigger
         bne   fadd1
         ldd   <ARGHO
         subd  <FACHO
         bne   fadd1

* same expo and same mantissa
         ldb   <FACSGN
         eorb  <ARGSGN
         bmi   fadd0       ; if not same sign => yield 0      
         inc   <FACEXP     ; otherwise => yield 2FAC
         pulu  pc
fadd0    sta   <FACEXP     ; zero
         pulu  pc

* mantissa is different; C=1 indicates |FAC| > |ARG|
fadd1    lda   <FACSGN
         eora  <ARGSGN
         sta   <ARGLO      ; add or sub ?
         
         ldx   <ARGHO
         bcc   fadd_cpy
         
         ldb   <FACEXP     ; FAC is bigger
         subb  <ARGEXP

         cmpb  #16         ; expo diff >= 16
         bcs   *+4
         pulu  pc          ; yes => done
        
fadd2    lda   <ARGLO      ; subtract ?
         bmi   fadds1      ; yes => goto fadds section
* same sign => add
         bsr   fastLSR     ; shift smaller mantissa
         addd  <FACHO
         bcc   fadd_end    ; msb not lost => done
         rora              ; lost => shift right 
         rorb              ; get it back
         inc   <FACEXP     ; fix expo
         bra   fadd_end    ; done
* sign differ => sub
fadds1   bsr   fastLSR     ; shift smaller mantissa
         negd
         addd  <FACHO
         bmi   fadd_end    ; msb set ? yes => done
fadds2   dec   <FACEXP     ; no => shift left
         beq   fadd_end    ; underflow => done
         lsld
         bpl   fadds2     ; loop till msb set
fadd_end std   <FACHO
         pulu  pc
         
fadd_cpy ldd   <FACHO      ; copy mantissa
         stx   <FACHO      
         tfr   d,x

         lda   <ARGSGN     ; copy sign
         sta   <FACSGN
         
         ldb   <ARGEXP     ; ARG is biger
         subb  <FACEXP

         lda   <ARGEXP     ; copy expo
         sta   <FACEXP
         
         cmpb  #16         ; expo diff >= 16
         bcs   fadd2
         pulu  pc
         endc

         ifne  USE_XTRA
ftoi     ldd   #$0232
         jsr   >EXTRA
         ldb   #4
         stb   <VALTYP
         ldd   <FACMO
         pulu  pc
         else
ftoi     ldb   <FACEXP
         bne   ftoi0
         clra
         pulu  pc
         
ftoi0    subb  #$80
         bhs   ftoi1
         
         ldb   <FACSGN     ; abs(num) <= 1
         sex
         tfr   a,b
         pulu  pc         ; $FFFF or $0000

ftoi1    subb  #16
         bcs   ftoi2
         ldd   #$7FFF
         tst   <FACSGN  
         bpl   ftoi1x
         comb
         coma
ftoi1x   pulu  pc          ; $8000 or $7FFF
         
ftoi2    negb              ; MANTISSA >> -b
         ldx   <FACHO
         bsr   fastLSR
         tst   <FACSGN
         bpl   ftoi3
         negd
ftoi3    pulu  pc
         endc

         ifeq  USE_XTRA
* D = X>>B (logical shift)
fastLSR  pshs  x
         ldx   #fastLSR3
         bitb  #$F0
         beq   fastLSR1
         ldd   #0
         jmp   ,x
         
fastLSR1 bitb  #$F8
         beq   fastLSR2
         
         negb
         addb  #fastLSR4-fastLSR3+8
         leax  b,x
         clra
         ldb   ,s
         jmp   ,x

         lsrb
         lsrb
         lsrb
         lsrb
         lsrb
         lsrb
         lsrb
fastLSR4 puls  x,pc             

fastLSR2 aslb
         negb
         leax  b,x
         ldd   ,s
         jmp   ,x
         
         lsrd
         lsrd
         lsrd
         lsrd
         lsrd
         lsrd
         lsrd
fastLSR3 puls  x,pc    
         
         endc

xtra     jsr   >EXTRA
         pulu  pc

         ifne  USE_XTRA
floor    ldb   #42
         bra   xtra
         else
floor    ldb   <FACEXP
         beq   floor0+2 ; zero
         
         subb  #$81
         bhs   floor1
         
         clra           ; here abs(num)<1
         ldb   <FACSGN  
         bpl   floor0   ; num>0 rounds to 0
         sta   <FACMO   
         ldd   #$8180   ; return -1         
floor0   std   <FACEXP
         pulu  pc

floor1   cmpb  #16      ; abs(num)>=1
         bcc   floor3   ; too big to truncate
         
         ldx   #floor4  ; $8000 >> b
         lslb
         abx
         ldd   ,x
            
         subd  #1       ; make mask

         anda  <FACHO   ; isolate fraction
         andb  <FACMO

         addd  #0       ; fraction==0 ?
         beq   floor3   ; yes==>exact int, done

         eora  <FACHO   ; mask out fraction
         eorb  <FACMO
         
         tst   <FACSGN  ; no, num>0 ? 
         bpl   floor2   ; yes => done
         addd  ,x       ; no => add 1
         bcc   floor2
         rora           ; overflow
         lsrb           ; shift mantissa
         inc   <FACEXP  ; fix exponent
floor2   std   <FACHO   ; save mantissa
floor3   pulu  pc
floor4   fdb   $8000,$4000,$2000,$1000
         fdb   $0800,$0400,$0200,$0100
         fdb   $0080,$0040,$0020,$0010
         fdb   $0008,$0004,$0002,$0001
         endc

MOVAM    macro
         ldd   \0
         stb   <ARGSGN
         orb   #128
         std   <ARGEXP
         lda   \0+2
         sta   <ARGMO
         pulu  pc
         endm

* D = ARG / D and ARG = ARG % D

         ifne  0
         
idivmod  pshs  x,u         
         ldx   #1
idivmod_ tsta
         bmi   idivmod1
         bne   idivmod0
         ldx   #9
         exg   a,b
         bra   idivmod_
idivmod0 leax  1,x
         lsld
         bpl   idivmod0
idivmod1 std   <FACMO
         ldd   <ARGMO
         ldu   #-1
         stu   <ARGMO
         ldu   #FACMO
idivmod2 cmpd  ,u
         bcs   idivmod3
         subd  ,u
idivmod3 rol   <ARGMO+1
         rol   <ARGMO
         lsr   ,u
         ror   1,u
         leax  -1,x
         bne   idivmod2
         ldx   <ARGMO
         std   <ARGMO
         tfr   x,d
         coma
         comb
         puls  x,u,pc

         else
         
idivmod  pshs  x
         ldx   #16
         std   <idivmod0+4,pcr
         std   <idivmod1-2,pcr
         ldd   #0
         lsl   <ARGMO+1
         rol   <ARGMO
idivmod0 rolb 
         rola
         cmpd  #0
         bcs   idivmod1
         subd  #0
idivmod1 rol   <ARGMO+1
         rol   <ARGMO
         leax  -1,x
         bne   idivmod0
         tfr   d,x
         ldd   <ARGMO
         stx   <ARGMO
         comb 
         coma  
         puls  x,pc
         
         endc

* affiche le temps mm:ss.d      
prtTime  lda   >STATUS
         ldb   >FORME
         pshs  d
         
         ldab  0,255-$20
         sta   >FORME
         andb  >STATUS
         stb   >STATUS        ; arret timer
                  
         ldd   <iTime
         std   <ARGMO
*         ldd   #36000
*         bsr   idivmod
*         bsr   prt10
*         ldb   #':
*         bsr   putc16
         ldd   #600
         bsr   idivmod
         bsr   prt100
         ldb   #'m
         bsr   putc16
         ldd   #10
         bsr   idivmod
         bsr   prt100
         ldb   #'.
         bsr   putc16
         ldb   <ARGMO+1
         bsr   prt10
         puls  d
         sta   >STATUS
         stb   >FORME
         rts
         
prt100   pshs  d
*         lda   1,s
*         clrb
         exg   a,b
prt100a  subd  #2559
         bcc   prt100a
         addd  #2559
         bsr   prt10
         tfr   a,b
         bsr   prt10
         puls  d,pc

* print a decimal
prt10    addb  #'0
*        bra   putc16

* prints a char in bm16
putc16   pshs  u,d,y
         subb  #31
         lda   #8
         mul
         addd  >PTGENE
         tfr   d,u         
         incb        ; sets b0
putc16_0 pshs  x,b
         lda   ,-u
*         lsra
*         ora   ,u
         bra   putc16_3
putc16_1 bsr   PLOT ; destroys B
putc16_2 leax  1,x
         lsla
putc16_3 bmi   putc16_1
         bne   putc16_2
         puls  x,b
         leay  1,y
         lslb        ; loops 8 times
         bne   putc16_0
         leax  8,x   ; next pos
         puls  u,d,y,pc

* faster BM16 version of PLOT ($E80F)
* FORM contains dedoubled color XX
PLOT     pshs  d,x
*         jsr   $E80F
*         puls  d,x,pc

         tfr   y,d      ; calc px address
         lda   #40
         mul
         adda  #$40
         tfr   d,x
         ldb   3,s
         lsrb
         lsrb
         abx
         
         ldb   >$E7C3   ; ramA or ramB ?
         orb   #1
         sbcb  #0
         stb   >$E7C3
         
         ldb   3,s      ; compute mask 
         lsrb           
         ldd   #$0FF0   
         bcc   *+5      
         ldd   #$F00F   
         
         andb  FORME    ; display pixel
         anda  ,x
         sta   ,x
         orb   ,x
         stb   ,x
         puls  d,x,pc
         
* print a string   
puts0    jsr   >PUTC
puts     ldb   ,x+
         bne   puts0
         rts
         
         setdp $ff

* timer routine, called every 1/10 sec
timert   inc   >iTime+1
         bne   timert1
         inc   >iTime+0
timert1  jmp   KBIN
         
   
inistr   fcb   $14      cursor off
         fcb   $1b,$5e  bm16
         fcb   $1b,$60  black border

cols     fcb   0
         fcb   $11,$22,$33,$44,$55,$66,$77
         fcb   $00,$88,$99,$aa,$bb
         fcb   $00,$cc,$dd,$ee,$ff
         
palette  fdb   $000,$100,$200,$500
         fdb   $C00,$C10,$C50,$CC0
         fdb   $010,$020,$050,$0A0
         fdb   $011,$022,$055,$0AA
         
vac      fdb   $7F88,$7F00,$7E80,$7E20
         fdb   $7D80,$7F08,$7D20,$7FB0
         
         fdb   $7C80,$7FD8,$7F18,$7FB8
         fdb   $7F48,$7FF8,$7E90,$7F30
         
         fdb   $7E00,$7EC0,$7F50,$7F90
         fdb   $0000,$7E70,$7FC0,$7F70
         
         fdb   $7FE8,$7E40,$7C40,$7DC0
         fdb   $7E10,$7EE0,$7C00,$7DA0
         
         fdb   $7F10,$7EF0,$7FC8,$7F78
         fdb   $7FF0,$7F20,$7F58,$7F98
         
         fdb   $7D40,$7F28,$7CC0,$7E60
         fdb   $7EA0,$7FA8,$7E30,$7DE0

         fdb   $8080,$7EB0,$7FA0,$7F38
         fdb   $7D60,$7B80,$7FD0,$7F40

         fdb   $7B00,$7F60,$7D00,$7FE0
         fdb   $7F80,$7F68,$7ED0,$7E50

c_3      fdb   $8240,$0000       ; 3 must follow c_m0p1
c_1o130  fdb   $797C,$0FC1       ; 1/130
c_m159p5 fdb   $889F,$8000       ; -159.5
c_99p5   fdb   $8747,$0000       ; 99.5

c_sph    fdb   110,144,$8100
         fdb   208,47,$8180

c_0p5    fdb   $8000,$0000       ; 0.5 (important: must have MSB set)
c_1      fdb   $8100,$0000       ; 1
c_2      fdb   $8200,$0000       ; 2
c_7      fdb   $8360,$0000       ; 7

ground0  fdb   $8400,$0000       ; 8
ground1  fdb   $8450,$0000       ; 13

         echo  Size = &(*-ini) bytes
(info)
*iTime    rmb   2
*iRnd     rmb   2
*iX       rmb   2
*iY       rmb   2
*i2X      rmb   2

iTime    equ   $61A1
iRnd     equ   $61A3
iX       equ   $61A5
iY       equ   $61A7
i2X      equ   $61A9

fX       rmb   4
fY       rmb   4
fZ       rmb   4

fU       rmb   4
fV       rmb   4
fW       rmb   4

         ifne  USE_XTRA*0
fI       rmb   4
         else
fI       equ   i2X+2
         endc
fE       rmb   4
fF       rmb   4
fP       rmb   4
fT       rmb   4

         ifne  USE_XTRA
fISqrtX  rmb   4
fISqrtY  rmb   4
         else
fISqrtX  equ   fI+4         
fISqrtY  equ   fI+8
         endc
         
fDivX    rmb   4

fCoord   rmb   2*320

         end   ini   